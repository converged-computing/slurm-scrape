{
    "url": "https://slurm.schedmd.com/priority_multifactor.html",
    "sections": [
        {
            "title": "\n\nSlurm Workload Manager\n\n",
            "content": "\n\nSchedMD\n\n"
        },
        {
            "title": "Multifactor Priority Plugin",
            "content": "Contents\n Introduction\n Multifactor Job Priority Plugin\n Job Priority Factors In General\n Age Factor\n Association Factor\n Job Size Factor\n Nice Factor\n Partition Factor\n Quality of Service (QOS) Factor\n Site Factor\n TRES Factors\n Fairshare Factor\n The sprio utility\n Configuration\n Configuration Example\nIntroductionBy default, Slurm has the priority/multifactor plugin set, which schedules\njobs based on several factorsIn most cases it is preferable to use the Multifactor Priority plugin,\nhowever basic First In, First Out scheduling is available by setting\nPriorityType=priority/basic in the slurm.conf file. FIFO scheduling\nshould be configured when Slurm is controlled by an external scheduler. (See\nConfiguration below)There are several considerations the scheduler makes when making\nscheduling decisions. Jobs are selected to be evaluated by the scheduler\nin the following order:\nJobs that can preempt\nJobs with an advanced reservation\nPartition PriorityTier\nJob priority\nJob submit time\nJob ID\nThis is important to keep in mind because the job with the highest priority\nmay not be the first to be evaluated by the scheduler. The job priority is\nconsidered when there are multiple jobs that can be evaluated at once, such\nas jobs requesting partitions with the same PriorityTier.Multifactor 'Factors'\n\n There are nine factors in the Multifactor Job Priority plugin that\ninfluence job priority:\n Age\n the length of time a job has been waiting in the queue, eligible to be scheduled\n Association\n a factor associated with each association\n Fair-share\n the difference between the portion of the computing resource that has been promised and the amount of resources that has been consumed\n Job size\n the number of nodes or CPUs a job is allocated\n Nice\n a factor that can be controlled by users to prioritize their own jobs.\n Partition\n a factor associated with each node partition\n QOS\n a factor associated with each Quality Of Service\n Site\n a factor dictated by an administrator or a site-developed job_submit or site_factor plugin\n TRES\n each TRES Type has its own factor for a job which represents the number of\nrequested/allocated TRES Type in a given partition\n Additionally, a weight can be assigned to each of the above\n  factors.  This provides the ability to enact a policy that blends a\n  combination of any of the above factors in any portion desired.  For\n  example, a site could configure fair-share to be the dominant factor\n  (say 70%), set the job size and the age factors to each contribute\n  15%, and set the partition and QOS influences to zero.Job Priority Factors In General\n\n The job's priority at any given time will be a weighted sum of all the factors that have been enabled in the slurm.conf file.  Job priority can be expressed as:\nJob_priority =\n\tsite_factor +\n\t(PriorityWeightAge) * (age_factor) +\n\t(PriorityWeightAssoc) * (assoc_factor) +\n\t(PriorityWeightFairshare) * (fair-share_factor) +\n\t(PriorityWeightJobSize) * (job_size_factor) +\n\t(PriorityWeightPartition) * (priority_job_factor) +\n\t(PriorityWeightQOS) * (QOS_factor) +\n\tSUM(TRES_weight_cpu * TRES_factor_cpu,\n\t    TRES_weight_<type> * TRES_factor_<type>,\n\t    ...)\n\t- nice_factor\n All of the factors in this formula are floating point numbers that\n  range from 0.0 to 1.0.  The weights are unsigned, 32 bit integers.\n  The job's priority is an integer that ranges between 0 and\n  4294967295.  The larger the number, the higher the job will be\n  positioned in the queue, and the sooner the job will be scheduled.\n  A job's priority, and hence its order in the queue, can vary over\n  time.  For example, the longer a job sits in the queue, the higher\n  its priority will grow when the age_weight is non-zero.The default behavior is for slurmctld to \"normalize\" the priority values\nin relation to the one with the highest value. This makes it so that the\nmost priority a job can get from any factor is equal to the\nPriorityWeight* value for that factor. Using Partitions as an example,\nif 'PartitionA' had a PriorityJobFactor of 20 and 'PartitionB' had a\nPriorityJobFactor of 10 and the PriorityWeightPartition was set\nto 5000, then the calculation for the priority that any job would gain for\nthe partition would look like this:\n\n# PartitionA\n5000 * (20 / 20) = 5000\n\n# PartitionB\n5000 * (10 / 20) = 2500\n\nYou can change the default behavior so that it doesn't normalize the\npriority values, but uses the raw PriorityJobFactor values instead,\nwith PriorityFlags=NO_NORMAL_PART. In that case the calculation of\nthe partition based priority would look like this:\n\n# PartitionA\n5000 * 20 = 100000\n\n# PartitionB\n5000 * 10 = 50000\n\nSee the other priority factors you can configure to not be normalized in the\nPriorityFlags section of the\ndocumentation. IMPORTANT: The weight values should be high enough to get a\n  good set of significant digits since all the factors are floating\n  point numbers from 0.0 to 1.0. For example, one job could have a\n  fair-share factor of .59534 and another job could have a fair-share\n  factor of .50002.  If the fair-share weight is only set to 10, both\n  jobs would have the same fair-share priority. Therefore, set the\n  weights high enough to avoid this scenario, starting around 1000 or\n  so for those factors you want to make predominant.Age FactorNote: Computing the age factor requires the installation\nand operation of the Slurm Accounting\nDatabase. The age factor represents the length of time a job has been sitting in the queue and eligible to run.  In general, the longer a job waits in the queue, the larger its age factor grows.  However, the age factor for a dependent job will not change while it waits for the job it depends on to complete.  Also, the age factor will not change when scheduling is withheld for a job whose node or time limits exceed the cluster's current limits. At some configurable length of time (PriorityMaxAge), the age factor will max out to 1.0.Association Factor Each association can be assigned an integer priority. The larger the\nnumber, the greater the job priority will be for jobs that request\nthis association. This priority value is normalized to the highest\npriority of all the association to become the association factor.Job Size FactorThe job size factor correlates to the number of nodes or CPUs the job has\nrequested.  This factor can be configured to favor larger jobs or smaller jobs\nbased on the state of the PriorityFavorSmall boolean in the slurm.conf\nfile.  When PriorityFavorSmall is NO, the larger the job, the greater\nits job size factor will be.  A job that requests all the nodes on the machine\nwill get a job size factor of 1.0.  When the PriorityFavorSmall Boolean\nis YES, the single node job will receive the 1.0 job size factor.The PriorityFlags value of SMALL_RELATIVE_TO_TIME alters this\nbehavior as follows. The job size in CPUs is divided by the time limit in\nminutes. The result is divided by the total number of CPUs in the system.\nThus a full-system job with a time limit of one will receive a job size factor\nof 1.0, while a tiny job with a large time limit will receive a job size factor\nclose to 0.0.Nice Factor Users can adjust the priority of their own jobs by setting the nice value\non their jobs. Like the system nice, positive values negatively impact a job's\npriority and negative values increase a job's priority. Only privileged users\ncan specify a negative value. The adjustment range is +/-2147483645.\nPartition Factor\n\n Each node partition can be assigned an integer priority.  The\nlarger the number, the greater the job priority will be for jobs that\nrequest to run in this partition.  This priority value is then\nnormalized to the highest priority of all the partitions to become the\npartition factor.Quality of Service (QOS) Factor\n\n Each QOS can be assigned an integer priority.  The larger the\nnumber, the greater the job priority will be for jobs that request\nthis QOS.  This priority value is then normalized to the highest\npriority of all the QOSs to become the QOS factor.Site Factor The site factor is a factor that can be set either using scontrol,\nthrough a job_submit or site_factor plugin. An example use case, might be a\njob_submit plugin\nthat sets a specific priority based on how many resources are requested.TRES Factors\nEach TRES Type has its own priority factor for a job which represents the amount\nof TRES Type requested/allocated in a given partition. For global TRES Types,\nsuch as Licenses and Burst Buffers, the factor represents the number of\nTRES Type requested/allocated in the whole system. The more a given TRES Type is\nrequested/allocated on a job, the greater the job priority will be for that job.\nFair-share Factor\n\nNote: Computing the fair-share factor requires the installation\nand operation of the Slurm Accounting\nDatabase to provide the assigned shares and the consumed,\ncomputing resources described below. The fair-share component to a job's priority influences the order in which a user's queued jobs are scheduled to run based on the portion of the computing resources they have been allocated and the resources their jobs have already consumed.  The fair-share factor does not involve a fixed allotment, whereby a user's access to a machine is cut off once that allotment is reached. Instead, the fair-share factor serves to prioritize queued jobs such that those jobs charging accounts that are under-serviced are scheduled first, while jobs charging accounts that are over-serviced are scheduled when the machine would otherwise go idle. Slurm's fair-share factor is a floating point number between 0.0 and 1.0 that reflects the shares of a computing resource that a user has been allocated and the amount of computing resources the user's jobs have consumed.  The higher the value, the higher is the placement in the queue of jobs waiting to be scheduled. By default, the computing resource is the computing cycles delivered by a\nmachine in the units of allocated_cpus*seconds. Other resources can be taken into\naccount by configuring a partition's TRESBillingWeights option. The\nTRESBillingWeights option allows you to account for consumed resources other\nthan just CPUs by assigning different billing weights to different Trackable\nResources (TRES) such as CPUs, nodes, memory, licenses and generic resources\n(GRES). For example, when billing only for CPUs, if a job requests 1CPU and 64GB\nof memory on a 16CPU, 64GB node the job will only be billed for 1CPU when it\nreally used the whole node.\n By default, when TRESBillingWeights is configured, a job is billed for each\nindividual TRES used. The billable TRES is calculated as the sum of all TRES\ntypes multiplied by their corresponding billing weight.\n For example, the following jobs on a partition configured with\nTRESBillingWeights=CPU=1.0,Mem=0.25G and 16CPU, 64GB nodes would be billed as:\n\n      CPUs       Mem GB\nJob1: (1 *1.0) + (60*0.25) = (1 + 15) = 16\nJob2: (16*1.0) + (1 *0.25) = (16+.25) = 16.25\nJob3: (16*1.0) + (60*0.25) = (16+ 15) = 31\n\n\nAnother method of calculating the billable TRES is by taking the MAX of the\nindividual TRESs on a node (e.g. cpus, mem, gres) plus the SUM of the global\nTRESs (e.g. licenses). For example the above job's billable TRES would\nbe calculated as:\n\n          CPUs      Mem GB\nJob1: MAX((1 *1.0), (60*0.25)) = 15\nJob2: MAX((15*1.0), (1 *0.25)) = 15\nJob3: MAX((16*1.0), (64*0.25)) = 16\n\nThis method is turned on by defining the MAX_TRES priority flags in the\nslurm.conf.\n\"Fair Tree\" Fairshare\nAs of the 19.05 release, the \"Fair Tree\" fairshare algorithm has been made the\ndefault. Please see the Fair Tree Fairshare\ndocumentation for further details.\n\"Classic\" Fairshare\n\n\nAs of the 19.05 release, the \"classic\" fairshare algorithm is no longer the\ndefault, and will only be used if PriorityFlags=NO_FAIR_TREE is\nexplicitly configured. Documentation describing that algorithm has been moved\nto a separate Classic Fairshare\ndocumentation page.\nThe sprio utility\n\n The sprio command provides a summary of the six factors\nthat comprise each job's scheduling priority.  While squeue has\nformat options (%p and %Q) that display a job's composite priority,\nsprio can be used to display a breakdown of the priority components\nfor each job.  In addition, the sprio -w option displays the\nweights (PriorityWeightAge, PriorityWeightFairshare, etc.) for each\nfactor as it is currently configured.ConfigurationThe following slurm.conf parameters are used to configure the Multifactor Job Priority Plugin. See slurm.conf(5) man page for more details.\n PriorityType\n Set this value to \"priority/multifactor\" to enable the Multifactor Job Priority Plugin.\n PriorityDecayHalfLife\n This determines the contribution of historical usage on the\n  composite usage value.  The larger the number, the longer past usage\n  affects fair-share.  If set to 0 no decay will be applied.  This is helpful if\n  you want to enforce hard time limits per association.  If set to 0\n  PriorityUsageResetPeriod must be set to some interval.\n  The unit is a time string (i.e. min, hr:min:00, days-hr:min:00, or\n  days-hr).  The default value is 7-0 (7 days).\n PriorityCalcPeriod\n The period of time in minutes in which the half-life decay will\n  be re-calculated.  The default value is 5 (minutes).\n PriorityUsageResetPeriod\n At this interval the usage of associations will be reset to 0.\n  This is used if you want to enforce hard limits of time usage per\n  association.  If PriorityDecayHalfLife is set to be 0 no decay will\n  happen and this is the only way to reset the usage accumulated by\n  running jobs.  By default this is turned off and it is advised to\n  use the PriorityDecayHalfLife option to avoid not having anything\n  running on your cluster, but if your schema is set up to only allow\n  certain amounts of time on your system this is the way to do it.\n  Applicable only if PriorityType=priority/multifactor. The unit is a\n  time string (i.e. NONE, NOW, DAILY, WEEKLY).  The default is NONE.\n\nNONE: Never clear historic usage. The default value.\nNOW: Clear the historic usage now. Executed at startup and reconfiguration time.\nDAILY: Cleared every day at midnight.\nWEEKLY: Cleared every week on Sunday at time 00:00.\nMONTHLY: Cleared on the first day of each month at time 00:00.\nQUARTERLY: Cleared on the first day of each quarter at time 00:00.\nYEARLY: Cleared on the first day of each year at time 00:00.\n\n PriorityFavorSmall\n A boolean that sets the polarity of the job size factor.  The\n  default setting is NO which results in larger node sizes having a\n  larger job size factor.  Setting this parameter to YES means that\n  the smaller the job, the greater the job size factor will be.\n PriorityMaxAge\n Specifies the queue wait time at which the age factor maxes out.\n  The unit is a time string (i.e. min, hr:min:00, days-hr:min:00, or\n  days-hr).  The default value is 7-0 (7 days).\n PriorityWeightAge\n An unsigned integer that scales the contribution of the age factor.\n PriorityWeightAssoc\n An unsigned integer that scales the contribution of the association factor.\n PriorityWeightFairshare\n An unsigned integer that scales the contribution of the fair-share factor.\n PriorityWeightJobSize\n An unsigned integer that scales the contribution of the job size factor.\n PriorityWeightPartition\n An unsigned integer that scales the contribution of the partition factor.\n PriorityWeightQOS\n An unsigned integer that scales the contribution of the quality of service factor.\n PriorityWeightTRES\n A list of TRES Types and weights that scales the contribution of each TRES\n  Type's factor.\n\n PriorityFlags\n Flags to modify priority behavior. Applicable only if\nPriorityType=priority/multifactor.\n\nACCRUE_ALWAYS: If set, priority age factor will be increased despite job\n\tdependencies or holds. Accrue limits are ignored.\nCALCULATE_RUNNING: If set, priorities will be recalculated not only for\n\tpending jobs, but also running and suspended jobs.\nDEPTH_OBLIVIOUS: If set, priority will be calculated based similar to the\n\tnormal multifactor calculation, but depth of the associations in the\n\ttree do not adversely effect their priority. This option automatically\n\tenables NO_FAIR_TREE.\nNO_FAIR_TREE: Disables the \"fair tree\" algorithm, and reverts to \"classic\"\n\tfair share priority scheduling.\nINCR_ONLY: If set, priority values will only increase in value. Job\n\tpriority will never decrease in value.\nMAX_TRES: If set, the weighted TRES value (e.g. TRESBillingWeights) is\n\tcalculated as the MAX of individual TRESs on a node (e.g. cpus, mem,\n\tgres) plus the sum of all global TRESs (e.g. licenses).\nNO_NORMAL_ALL: If set, all NO_NORMAL_* flags are set.\nNO_NORMAL_ASSOC: If set, the association factor is not normalized against\n\tthe highest association priority.\nNO_NORMAL_PART: If set, the partition factor is not normalized against the\n\thighest partition PriorityJobFactor.\nNO_NORMAL_QOS: If set, the QOS factor is not normalized against the\n\thighest qos priority.\nNO_NORMAL_TRES: If set, the TRES factor is not normalized against the job's\n\tpartition TRES counts.\nSMALL_RELATIVE_TO_TIME: If set, the job's size component will be based\n\tupon not the job size alone, but the job's size divided by its time\n\tlimit.\n\n Note:  As stated above, the six priority factors range from 0.0 to 1.0.  As such, the PriorityWeight terms may need to be set to a high enough value (say, 1000) to resolve very tiny differences in priority factors.  This is especially true with the fair-share factor, where two jobs may differ in priority by as little as .001. (or even less!)Configuration Example\n\n The following are sample slurm.conf file settings for the\n  Multifactor Job Priority Plugin. The first example is for running the plugin applying decay over\n  time to reduce usage.  Hard limits can be used in this\n  configuration, but will have less effect since usage will decay\n  over time instead of having no decay over time.\n# Activate the Multifactor Job Priority Plugin with decay\nPriorityType=priority/multifactor\n\n# 2 week half-life\nPriorityDecayHalfLife=14-0\n\n# The larger the job, the greater its job size priority.\nPriorityFavorSmall=NO\n\n# The job's age factor reaches 1.0 after waiting in the\n# queue for 2 weeks.\nPriorityMaxAge=14-0\n\n# This next group determines the weighting of each of the\n# components of the Multifactor Job Priority Plugin.\n# The default value for each of the following is 1.\nPriorityWeightAge=1000\nPriorityWeightFairshare=10000\nPriorityWeightJobSize=1000\nPriorityWeightPartition=1000\nPriorityWeightQOS=0 # don't use the qos factor\n This example is for running the plugin with no decay on usage,\n  thus making a reset of usage necessary.\n# Activate the Multifactor Job Priority Plugin with decay\nPriorityType=priority/multifactor\n\n# apply no decay\nPriorityDecayHalfLife=0\n\n# reset usage after 1 month\nPriorityUsageResetPeriod=MONTHLY\n\n# The larger the job, the greater its job size priority.\nPriorityFavorSmall=NO\n\n# The job's age factor reaches 1.0 after waiting in the\n# queue for 2 weeks.\nPriorityMaxAge=14-0\n\n# This next group determines the weighting of each of the\n# components of the Multifactor Job Priority Plugin.\n# The default value for each of the following is 1.\nPriorityWeightAge=1000\nPriorityWeightFairshare=10000\nPriorityWeightJobSize=1000\nPriorityWeightPartition=1000\nPriorityWeightQOS=0 # don't use the qos factor\nLast modified 03 August 2023"
        },
        {
            "title": "Navigation",
            "content": "\nSlurm Workload Manager\nVersion 24.05\n\n\nAbout\n\nOverview\nRelease Notes\n\n\n\nUsing\n\nDocumentation\nFAQ\nPublications\n\n\n\nInstalling\n\nDownload\nRelated Software\nInstallation Guide\n\n\n\nGetting Help\n\nMailing Lists\nSupport and Training\nTroubleshooting\n\n\n"
        }
    ]
}