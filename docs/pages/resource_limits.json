{
    "url": "https://slurm.schedmd.com/resource_limits.html",
    "sections": [
        {
            "title": "\n\nSlurm Workload Manager\n\n",
            "content": "\n\nSchedMD\n\n"
        },
        {
            "title": "Resource Limits",
            "content": "Familiarity with Slurm's Accounting web page\nis strongly recommended before use of this document.HierarchySlurm's hierarchical limits are enforced in the following order\n  with Job QOS and Partition QOS order being reversible by using the QOS\n  flag 'OverPartQOS':\nPartition QOS limit\nJob QOS limit\nUser association\nAccount association(s), ascending the hierarchy\nRoot/Cluster association\nPartition limit\nNone\nNote: If limits are defined at multiple points in this hierarchy,\nthe point in this list where the limit is first defined will be used.\nConsider the following example:\nMaxJobs=20 and MaxSubmitJobs is undefined in the partition QOS\nNo limits are set in the job QOS and\nMaxJobs=4 and MaxSubmitJobs=50 in the user association\nThe limits in effect will be MaxJobs=20 and MaxSubmitJobs=50.Note: The precedence order specified above is respected except for the\nfollowing limits: Max[Time|Wall], [Min|Max]Nodes. For these limits, even\nif the job is enforced with QOS and/or Association limits, it can't\ngo over the limit imposed at Partition level, even if it listed at the bottom.\nSo the default for these 3 types of limits is that they are upper bound by the\nPartition one. This Partition level bound can be ignored if\nthe respective QOS PartitionTimeLimit and/or Partition[Max|Min]Nodes flags\nare set, then the job would be enforced the limits imposed at QOS\nand/or association level respecting the order above.\nGrp* limits are also an exception. A more restrictive limit at the\nAccount level will be enforced before a less restrictive limit at the User\nlevel. This is due to the nature of the limit being enforced, requiring that\nthe limit at the highest level not be exceeded.\nConfigurationScheduling policy information must be stored in a database\nas specified by the AccountingStorageType configuration parameter\nin the slurm.conf configuration file.\nInformation can be recorded in a MySQL or\nMariaDB database.\nFor security and performance reasons, the use of\nSlurmDBD (Slurm Database Daemon) as a front-end to the\ndatabase is strongly recommended.\nSlurmDBD uses a Slurm authentication plugin (e.g. MUNGE).\nSlurmDBD also uses an existing Slurm accounting storage plugin\nto maximize code reuse.\nSlurmDBD uses data caching and prioritization of pending requests\nin order to optimize performance.\nWhile SlurmDBD relies upon existing Slurm plugins for authentication\nand database use, the other Slurm commands and daemons are not required\non the host where SlurmDBD is installed.\nOnly the slurmdbd and slurm-plugins RPMs are required\nfor SlurmDBD execution.Both accounting and scheduling policies are configured based upon\nan association. An association is a 4-tuple consisting\nof the cluster name, bank account, user and (optionally) the Slurm\npartition.\nIn order to enforce scheduling policy, set the value of\nAccountingStorageEnforce.\nThis option contains a comma separated list of options you may want to\nenforce.  The valid options are:\n\nassociations - This will prevent users from running jobs if\ntheir association is not in the database. This option will\nprevent users from accessing invalid accounts.\n\nlimits - This will enforce limits set to associations.  By setting\n  this option, the 'associations' option is also set.\n\nqos - This will require all jobs to specify (either overtly or by\ndefault) a valid qos (Quality of Service).  QOS values are defined for\neach association in the database.  By setting this option, the\n'associations' option is also set.\n\nsafe - This will ensure a job will only be launched when using an\n  association or qos that has a TRES-minutes limit set if the job will be\n  able to run to completion. Without this option set, jobs will be\n  launched as long as their usage hasn't reached the TRES-minutes limit\n  which can lead to jobs being launched but then killed when the limit is\n  reached.\n  With the 'safe' option set, a job won't be killed due to limits,\n  even if the limits are changed after the job was started and the\n  association or qos violates the updated limits.\n  By setting this option, both the 'associations' option and the\n  'limits' option are set automatically.\n\nwckeys - This will prevent users from running jobs under a wckey\n  that they don't have access to.  By using this option, the\n  'associations' option is also set.  The 'TrackWCKey' option is also\n  set to true.\n\n\nNOTE: The association is a combination of cluster, account,\nuser names and optional partition name.\n\nWithout AccountingStorageEnforce being set (the default behavior)\njobs will be executed based upon policies configured in Slurm on each\ncluster.\n\nTools\nThe tool used to manage accounting policy is sacctmgr.\nIt can be used to create and delete cluster, user, bank account,\nand partition records plus their combined association record.\nSee man sacctmgr for details on this tools and examples of\nits use.\nChanges made to the scheduling policy are uploaded to\nthe Slurm control daemons on the various clusters and take effect\nimmediately. When an association is deleted, all running or pending\njobs which belong to that association are immediately canceled.\nWhen limits are lowered, running jobs will not be canceled to\nsatisfy the new limits, but the new lower limits will be enforced.\nAssociation specific limits and scheduling policies\n\n\nThese represent the limits and scheduling policies relevant to Associations.\nWhen dealing with Associations, most of these limits are available\nnot only for the user association, but also for each cluster and account.\nLimits and policies are applied in the following order:\n\n1. The option specified for the user association.\n\n2. The option specified for the account.\n\n3. The option specified for the cluster.\n\n4. If nothing is configured at the above levels, no limit will be applied.\n\nThese are just the limits and policies for Associations. For a more\ncomplete description of the columns available to be displayed, see the\n\nsacctmgr man page.\n\nFairshare\n\nInteger value used for determining priority.\n  Essentially this is the amount of claim this association and its\n  children have to the above system. Can also be the string \"parent\",\n  when used on a user this means that the parent association is used\n  for fairshare.  If Fairshare=parent is set on an account, that\n  account's children will be effectively re-parented for fairshare\n  calculations to the first parent of their parent that is not\n  Fairshare=parent.  Limits remain the same, only its fairshare value\n  is affected.\n\nGrpJobs\n\nThe total number of jobs able to run at any given\n  time from an association and its children.  If\n  this limit is reached, new jobs will be queued but only allowed to\n  run after previous jobs complete from this group.\n\nGrpJobsAccrue\n\nThe total number of pending jobs able to accrue age\n  priority at any given time from an association and its children.  If\n  this limit is reached, new jobs will be queued but not accrue age priority\n  until after previous jobs are removed from pending in this group.\n  This limit does not determine if the job can run or not, it only limits the\n  age factor of the priority.\n\nGrpSubmitJobs\n\nThe total number of jobs able to be submitted\n  to the system at any given time from an association and its children.\n  If this limit is reached, new submission requests will be\n  denied until previous jobs complete from this group.\n\nGrpTRES\n\nThe total count of TRES able to be used at any given\n  time from jobs running from an association and its children. If\n  this limit is reached, new jobs will be queued but only allowed to\n  run after resources have been relinquished from this group.\n\nGrpTRESMins\n\nThe total number of TRES minutes that can\n  possibly be used by past, present and future jobs\n  running from an association and its children. If any limit is reached,\n  all running jobs with that TRES in this group will be killed, and no new\n  jobs will be allowed to run.  This usage is decayed (at a rate of\n  PriorityDecayHalfLife).  It can also be reset (according to\n  PriorityUsageResetPeriod) in order to allow jobs to run against the\n  association tree.\n  This limit only applies when using the Priority Multifactor plugin.\n\nGrpTRESRunMins\n\nUsed to limit the combined total number of TRES\n  minutes used by all jobs running with an association and its\n  children.  This takes into consideration time limit of\n  running jobs and consumes it. If the limit is reached, no new jobs\n  are started until other jobs finish to allow time to free up.\n\nGrpWall\n\nThe maximum wall clock time running jobs are able\n  to be allocated in aggregate for an association and its children.\n  If this limit is reached, future jobs in this association will be\n  queued until they are able to run inside the limit.\n  This usage is decayed (at a rate of\n  PriorityDecayHalfLife).  It can also be reset (according to\n  PriorityUsageResetPeriod) in order to allow jobs to run against the\n  association tree again.\n\nMaxJobs\n\nThe total number of jobs able to run at any given\n  time for the given association.  If this limit is reached, new jobs will\n  be queued but only allowed to run after existing jobs in the association\n  complete.\n\nMaxJobsAccrue\n\nThe maximum number of pending jobs able to accrue age\n  priority at any given time for the given association.  If this limit is\n  reached, new jobs will be queued but will not accrue age priority\n  until after existing jobs in the association are moved from a pending state.\n  This limit does not determine if the job can run, it only limits the\n  age factor of the priority.\n\nMaxSubmitJobs\n\nThe maximum number of jobs able to be submitted\n  to the system at any given time from the given association.  If\n  this limit is reached, new submission requests will be denied until\n  existing jobs in this association complete.\n\nMaxTRESMinsPerJob\n\nA limit of TRES minutes to be used by a job.\n  If this limit is reached, the job will be killed if not running in\n  Safe mode, otherwise the job will pend until enough time is given to\n  complete the job.\n\nMaxTRESPerJob\n\nThe maximum size in TRES any given job can\n  have from the association.\n\nMaxTRESPerNode\n\nThe maximum size in TRES each node in a job\n  allocation can use.\n\n\nMaxWallDurationPerJob\n\nThe maximum wall clock time any individual job\n  can run for in the given association.  If this limit is reached,\n  the job will be denied at submission.\n\nMinPrioThreshold\n\nMinimum priority required to reserve resources\n  in the given association. Used to override bf_min_prio_reserve.\n  See \n  bf_min_prio_reserve for details.\n\nQOS\n\ncomma separated list of QOSs an association is\n  able to run.\n\n\nNOTE: When modifying a TRES field with sacctmgr, one must\nspecify which TRES to modify (see TRES for complete\nlist) as in the following examples: \n\nSET:\nsacctmgr modify user bob set GrpTRES=cpu=1500,mem=200,gres/gpu=50\nUNSET:\nsacctmgr modify user bob set GrpTRES=cpu=-1,mem=-1,gres/gpu=-1\n\nQOS specific limits and scheduling policies\n\n\nAs noted above, the default behavior is that\na limit set on a Partition QOS will be applied before a limit on the job's\nrequested QOS. You can change this behavior with the OverPartQOS\nflag.\nUnless noted, if a job request breaches a given limit\non its own, the job will pend unless the job's QOS has the DenyOnLimit\nflag set, which will cause the job to be denied at submission.  When\nGrp limits are considered with respect to this flag the Grp limit\nis treated as a Max limit.\n\nGraceTime\n\nPreemption grace time to be extended to a job which\n  has been selected for preemption in the format of\n  <hh>:<mm>:<ss>. The default value is zero,\n  meaning no preemption grace time is allowed on this QOS. This value\n  is only meaningful for QOS PreemptMode=CANCEL and PreemptMode=REQUEUE.\n\nGrpJobs\n\nThe total number of jobs able to run at any given time\n  from a QOS. If this limit is reached, new jobs will be queued but only\n  allowed to run after previous jobs complete from this group.\n\nGrpJobsAccrue\n\nThe total number of pending jobs able to accrue age priority at any\n  given time from a QOS. If this limit is reached, new jobs will be queued but\n  will not accrue age based priority until after previous jobs are removed\n  from pending in this group. This limit does not determine if the job can\n  run or not, it only limits the age factor of the priority. This limit only\n  applies to the job's QOS and not the partition's QOS.\n\nGrpSubmitJobs\n\nThe total number of jobs able to be submitted to the system at any\n  given time from a QOS. If this limit is reached, new submission requests\n  will be denied until previous jobs complete from this group.\n\nGrpTRES\n\nThe total count of TRES able to be used at any given time from jobs\n  running from a QOS. If this limit is reached, new jobs will be queued but\n  only allowed to run after resources have been relinquished from this group.\n\nGrpTRESMins\n\nThe total number of TRES minutes that can possibly be used by past,\n  present and future jobs running from a QOS. If any limit is reached,\n  all running jobs with that TRES in this group will be killed, and no new\n  jobs will be allowed to run.  This usage is decayed (at a rate of\n  PriorityDecayHalfLife).  It can also be reset (according to\n  PriorityUsageResetPeriod) in order to allow jobs to run against the\n  QOS again.  QOS that have the NoDecay flag set do not decay GrpTRESMins,\n  see QOS Options for details.\n  This limit only applies when using the Priority Multifactor plugin.\n\nGrpTRESRunMins\n\nUsed to limit the combined total number of TRES\n  minutes used by all jobs running with a QOS.  This takes into\n  consideration the time limit of running jobs and consumes it.\n  If the limit is reached, no new jobs are started until other jobs\n  finish to allow time to free up.\n\nGrpWall\n\nThe maximum wall clock time running jobs are able\n  to be allocated in aggregate for a QOS. If this limit is reached,\n  future jobs in this QOS will be queued until they are able to run\n  inside the limit. This usage is decayed (at a rate of\n  PriorityDecayHalfLife).  It can also be reset (according to\n  PriorityUsageResetPeriod) in order to allow jobs to run against the\n  QOS again.  QOS that have the NoDecay flag set do not decay GrpWall.\n  See QOS Options for details.\n\nLimitFactor\n\nA float that is factored into an associations [Grp|Max]TRES limits.\n  For example, if the LimitFactor is 2, then an association with a GrpTRES of\n  30 CPUs would be allowed to allocate 60 CPUs when running under this QOS.\n\n  NOTE: This factor is only applied to associations running in this\n  QOS and is not applied to any limits in the QOS itself.\n\nMaxJobsAccruePerAccount\n\nThe maximum number of pending jobs an\n  account (or sub-account) can have accruing age priority at any given time.\n  This limit does not determine if the job can run, it only limits the\n  age factor of the priority.\n\nMaxJobsAccruePerUser\n\nThe maximum number of pending jobs a\n  user can have accruing age priority at any given time.\n  This limit does not determine if the job can run, it only limits the\n  age factor of the priority.\n\nMaxJobsPerAccount\n\nThe maximum number of jobs an account (or sub-account) can have running at\n  a given time.\n\nMaxJobsPerUser\n\nThe maximum number of jobs a user can\n  have running at a given time.\n\nMaxSubmitJobsPerAccount\n\nThe maximum number of jobs an account (or sub-account) can have running and\n  pending at a given time.\n\nMaxSubmitJobsPerUser\n\nThe maximum number of jobs a user can\n  have running and pending at a given time.\n\nMaxTRESMinsPerJob\n\nMaximum number of TRES minutes each job is able to use.\n\nMaxTRESPerAccount\n\nThe maximum number of TRES an account can\n  allocate at a given time.\n\nMaxTRESPerJob\n\nThe maximum number of TRES each job is able to use.\n\nMaxTRESPerNode\n\nThe maximum number of TRES each node in a job allocation can use.\n\nMaxTRESPerUser\n\nThe maximum number of TRES a user can\n  allocate at a given time.\n\nMaxWallDurationPerJob\n\nMaximum wall clock time each job is able to use. Format is <min>\n  or <min>:<sec> or <hr>:<min>:<sec> or\n  <days>-<hr>:<min>:<sec> or <days>-<hr>.\n  The value is recorded in minutes with rounding as needed.\n\nMinPrioThreshold\n\nMinimum priority required to reserve resources when scheduling.\n\nMinTRESPerJob\n\nThe minimum size in TRES any given job can\n  have when using the requested QOS.\n\nUsageFactor\n\nA float that is factored into a job's TRES usage (e.g. RawUsage,\n  TRESMins, TRESRunMins). For example, if the usagefactor was 2, for every\n  TRESBillingUnit second a job ran it would count for 2. If the usagefactor\n  was .5, every second would only count for half of the time.\n  A setting of 0 would add no timed usage from the job.\n\n  The usage factor only applies to the job's QOS and not the partition QOS.\n  \n  If the UsageFactorSafe flag is set and AccountingStorageEnforce includes\n  Safe, jobs will only be able to run if the job can run to completion\n  with the UsageFactor applied, and won't be killed due to limits.\n  \n  If the UsageFactorSafe flag is not set and AccountingStorageEnforce includes\n  Safe, a job will be able to be scheduled without the UsageFactor\n  applied and won't be killed due to limits.\n  \n  If the UsageFactorSafe flag is not set and AccountingStorageEnforce does\n  not include Safe, a job will be scheduled as long as the limits are\n  not reached, but could be killed due to limits.\n  \n  See \n  AccountingStorageEnforce in the slurm.conf man page.\n\n\nThe MaxNodes and MaxTime options already exist in\nSlurm's configuration on a per-partition basis, but the above options\nprovide the ability to impose limits on a per-user basis.  The\nMaxJobs option provides an entirely new mechanism for Slurm to\ncontrol the workload any individual may place on a cluster in order to\nachieve some balance between users.\nWhen assigning limits to a QOS to use for a Partition QOS,\nkeep in mind that those limits are enforced at the QOS level, not\nindividually for each partition.  For example, if a QOS has a\nGrpTRES=cpu=20 limit defined and the QOS is assigned to two\nunique partitions, users will be limited to 20 CPUs for the QOS\nrather than being allowed 20 CPUs for each partition.\nFair-share scheduling is based upon the hierarchical bank account\ndata maintained in the Slurm database.  More information can be found\nin the priority/multifactor\nplugin description.\nSpecific limits over GRES\n\n\n When a GRES has a type associated with it and a limit is applied\n  over this specific type (e.g. MaxTRESPerUser=gres/gpu:tesla=1) if a\n  user requests a generic gres, the type's limit will not be enforced. In this\n  situation an additional lua job submit plugin to check the user request may\n  become useful. For example, if one requests --gres=gpu:2 having a\n  limit set of MaxTRESPerUser=gres/gpu:tesla=1, the limit won't be\n  enforced so it will still be possible to get two teslas.\n\n\n  This is due to a design limitation. The only way to enforce such a limit\n  is to combine the specification of the limit with a job submit plugin that\n  forces the user to always request a specific type model.\n\n\n  An example of basic lua job submit plugin function could be:\n\n\nfunction slurm_job_submit(job_desc, part_list, submit_uid)\n   gres_request = \"\"\n   t = {job_desc.tres_per_job,\n\tjob_desc.tres_per_socket,\n\tjob_desc.tres_per_task,\n\tjob_desc.tres_per_node}\n   for k in pairs(t) do\n\tgres_request = gres_request .. t[k] .. \",\"\n   end\n   if (gres_request ~= nil)\n   then\n      for g in gres_request:gmatch(\"[^,]+\")\n      do\n\t bad = string.match(g,'^gres/gpu[:=]*[0-9]*$')\n\t if (bad ~= nil)\n\t then\n\t    slurm.log_info(\"User specified gpu GRES without type: %s\", bad)\n\t    slurm.user_msg(\"You must always specify a type when requesting gpu GRES\")\n\t    return slurm.ERROR\n\t end\n      end\n   end\nend\n\n Having this script and the limit in place will force the users to always\n  specify a gpu with its type, thus enforcing the limits for each specific\n  model.\n\nWhen TRESBillingWeights are defined for a partition, both typed and\nnon-typed resources should be included. For example, if you have 'tesla' GPUs\nin one partition and you only define the billing weights for the 'tesla' typed\nGPU resource, then those weights will not be applied to the generic GPUs.\nIt is also advisable to set AccountingStorageTRES for both generic\n  and specific gres types, otherwise requests that ask for the generic instance\n  of a gres won't be accounted for. For example, to track generic GPUs and\n  Tesla GPUs, you would set this in your slurm.conf:\n\n\n  AccountingStorageTRES=gres/gpu,gres/gpu:tesla\n\n\n  See Trackable Resources TRES for details.\n\nJob Reason Codes\n\n\nWhen a pending job is evaluated by the scheduler but found to exceed a\nconfigured resource limit, a corresponding reason will be assigned to the job.\nMore details can be found on the Job Reason\nCodes page. More details about scheduling can be found in the\n Scheduling Configuration Guide.\nLast modified 27 September 2024\n"
        },
        {
            "title": "Navigation",
            "content": "\nSlurm Workload Manager\nVersion 24.05\n\n\nAbout\n\nOverview\nRelease Notes\n\n\n\nUsing\n\nDocumentation\nFAQ\nPublications\n\n\n\nInstalling\n\nDownload\nRelated Software\nInstallation Guide\n\n\n\nGetting Help\n\nMailing Lists\nSupport and Training\nTroubleshooting\n\n\n"
        },
        {
            "title": "Tools",
            "content": "The tool used to manage accounting policy is sacctmgr.\nIt can be used to create and delete cluster, user, bank account,\nand partition records plus their combined association record.\nSee man sacctmgr for details on this tools and examples of\nits use.Changes made to the scheduling policy are uploaded to\nthe Slurm control daemons on the various clusters and take effect\nimmediately. When an association is deleted, all running or pending\njobs which belong to that association are immediately canceled.\nWhen limits are lowered, running jobs will not be canceled to\nsatisfy the new limits, but the new lower limits will be enforced.Association specific limits and scheduling policies\n\nThese represent the limits and scheduling policies relevant to Associations.\nWhen dealing with Associations, most of these limits are available\nnot only for the user association, but also for each cluster and account.\nLimits and policies are applied in the following order:\n\n1. The option specified for the user association.\n\n2. The option specified for the account.\n\n3. The option specified for the cluster.\n\n4. If nothing is configured at the above levels, no limit will be applied.\nThese are just the limits and policies for Associations. For a more\ncomplete description of the columns available to be displayed, see the\n\nsacctmgr man page.\nFairshare\n\nInteger value used for determining priority.\n  Essentially this is the amount of claim this association and its\n  children have to the above system. Can also be the string \"parent\",\n  when used on a user this means that the parent association is used\n  for fairshare.  If Fairshare=parent is set on an account, that\n  account's children will be effectively re-parented for fairshare\n  calculations to the first parent of their parent that is not\n  Fairshare=parent.  Limits remain the same, only its fairshare value\n  is affected.\n\nGrpJobs\n\nThe total number of jobs able to run at any given\n  time from an association and its children.  If\n  this limit is reached, new jobs will be queued but only allowed to\n  run after previous jobs complete from this group.\n\nGrpJobsAccrue\n\nThe total number of pending jobs able to accrue age\n  priority at any given time from an association and its children.  If\n  this limit is reached, new jobs will be queued but not accrue age priority\n  until after previous jobs are removed from pending in this group.\n  This limit does not determine if the job can run or not, it only limits the\n  age factor of the priority.\n\nGrpSubmitJobs\n\nThe total number of jobs able to be submitted\n  to the system at any given time from an association and its children.\n  If this limit is reached, new submission requests will be\n  denied until previous jobs complete from this group.\n\nGrpTRES\n\nThe total count of TRES able to be used at any given\n  time from jobs running from an association and its children. If\n  this limit is reached, new jobs will be queued but only allowed to\n  run after resources have been relinquished from this group.\n\nGrpTRESMins\n\nThe total number of TRES minutes that can\n  possibly be used by past, present and future jobs\n  running from an association and its children. If any limit is reached,\n  all running jobs with that TRES in this group will be killed, and no new\n  jobs will be allowed to run.  This usage is decayed (at a rate of\n  PriorityDecayHalfLife).  It can also be reset (according to\n  PriorityUsageResetPeriod) in order to allow jobs to run against the\n  association tree.\n  This limit only applies when using the Priority Multifactor plugin.\n\nGrpTRESRunMins\n\nUsed to limit the combined total number of TRES\n  minutes used by all jobs running with an association and its\n  children.  This takes into consideration time limit of\n  running jobs and consumes it. If the limit is reached, no new jobs\n  are started until other jobs finish to allow time to free up.\n\nGrpWall\n\nThe maximum wall clock time running jobs are able\n  to be allocated in aggregate for an association and its children.\n  If this limit is reached, future jobs in this association will be\n  queued until they are able to run inside the limit.\n  This usage is decayed (at a rate of\n  PriorityDecayHalfLife).  It can also be reset (according to\n  PriorityUsageResetPeriod) in order to allow jobs to run against the\n  association tree again.\n\nMaxJobs\n\nThe total number of jobs able to run at any given\n  time for the given association.  If this limit is reached, new jobs will\n  be queued but only allowed to run after existing jobs in the association\n  complete.\n\nMaxJobsAccrue\n\nThe maximum number of pending jobs able to accrue age\n  priority at any given time for the given association.  If this limit is\n  reached, new jobs will be queued but will not accrue age priority\n  until after existing jobs in the association are moved from a pending state.\n  This limit does not determine if the job can run, it only limits the\n  age factor of the priority.\n\nMaxSubmitJobs\n\nThe maximum number of jobs able to be submitted\n  to the system at any given time from the given association.  If\n  this limit is reached, new submission requests will be denied until\n  existing jobs in this association complete.\n\nMaxTRESMinsPerJob\n\nA limit of TRES minutes to be used by a job.\n  If this limit is reached, the job will be killed if not running in\n  Safe mode, otherwise the job will pend until enough time is given to\n  complete the job.\n\nMaxTRESPerJob\n\nThe maximum size in TRES any given job can\n  have from the association.\n\nMaxTRESPerNode\n\nThe maximum size in TRES each node in a job\n  allocation can use.\n\n\nMaxWallDurationPerJob\n\nThe maximum wall clock time any individual job\n  can run for in the given association.  If this limit is reached,\n  the job will be denied at submission.\n\nMinPrioThreshold\n\nMinimum priority required to reserve resources\n  in the given association. Used to override bf_min_prio_reserve.\n  See \n  bf_min_prio_reserve for details.\n\nQOS\n\ncomma separated list of QOSs an association is\n  able to run.\n\nNOTE: When modifying a TRES field with sacctmgr, one must\nspecify which TRES to modify (see TRES for complete\nlist) as in the following examples: \nSET:\nsacctmgr modify user bob set GrpTRES=cpu=1500,mem=200,gres/gpu=50\nUNSET:\nsacctmgr modify user bob set GrpTRES=cpu=-1,mem=-1,gres/gpu=-1\nQOS specific limits and scheduling policies\n\nAs noted above, the default behavior is that\na limit set on a Partition QOS will be applied before a limit on the job's\nrequested QOS. You can change this behavior with the OverPartQOS\nflag.Unless noted, if a job request breaches a given limit\non its own, the job will pend unless the job's QOS has the DenyOnLimit\nflag set, which will cause the job to be denied at submission.  When\nGrp limits are considered with respect to this flag the Grp limit\nis treated as a Max limit.\nGraceTime\n\nPreemption grace time to be extended to a job which\n  has been selected for preemption in the format of\n  <hh>:<mm>:<ss>. The default value is zero,\n  meaning no preemption grace time is allowed on this QOS. This value\n  is only meaningful for QOS PreemptMode=CANCEL and PreemptMode=REQUEUE.\n\nGrpJobs\n\nThe total number of jobs able to run at any given time\n  from a QOS. If this limit is reached, new jobs will be queued but only\n  allowed to run after previous jobs complete from this group.\n\nGrpJobsAccrue\n\nThe total number of pending jobs able to accrue age priority at any\n  given time from a QOS. If this limit is reached, new jobs will be queued but\n  will not accrue age based priority until after previous jobs are removed\n  from pending in this group. This limit does not determine if the job can\n  run or not, it only limits the age factor of the priority. This limit only\n  applies to the job's QOS and not the partition's QOS.\n\nGrpSubmitJobs\n\nThe total number of jobs able to be submitted to the system at any\n  given time from a QOS. If this limit is reached, new submission requests\n  will be denied until previous jobs complete from this group.\n\nGrpTRES\n\nThe total count of TRES able to be used at any given time from jobs\n  running from a QOS. If this limit is reached, new jobs will be queued but\n  only allowed to run after resources have been relinquished from this group.\n\nGrpTRESMins\n\nThe total number of TRES minutes that can possibly be used by past,\n  present and future jobs running from a QOS. If any limit is reached,\n  all running jobs with that TRES in this group will be killed, and no new\n  jobs will be allowed to run.  This usage is decayed (at a rate of\n  PriorityDecayHalfLife).  It can also be reset (according to\n  PriorityUsageResetPeriod) in order to allow jobs to run against the\n  QOS again.  QOS that have the NoDecay flag set do not decay GrpTRESMins,\n  see QOS Options for details.\n  This limit only applies when using the Priority Multifactor plugin.\n\nGrpTRESRunMins\n\nUsed to limit the combined total number of TRES\n  minutes used by all jobs running with a QOS.  This takes into\n  consideration the time limit of running jobs and consumes it.\n  If the limit is reached, no new jobs are started until other jobs\n  finish to allow time to free up.\n\nGrpWall\n\nThe maximum wall clock time running jobs are able\n  to be allocated in aggregate for a QOS. If this limit is reached,\n  future jobs in this QOS will be queued until they are able to run\n  inside the limit. This usage is decayed (at a rate of\n  PriorityDecayHalfLife).  It can also be reset (according to\n  PriorityUsageResetPeriod) in order to allow jobs to run against the\n  QOS again.  QOS that have the NoDecay flag set do not decay GrpWall.\n  See QOS Options for details.\n\nLimitFactor\n\nA float that is factored into an associations [Grp|Max]TRES limits.\n  For example, if the LimitFactor is 2, then an association with a GrpTRES of\n  30 CPUs would be allowed to allocate 60 CPUs when running under this QOS.\n\n  NOTE: This factor is only applied to associations running in this\n  QOS and is not applied to any limits in the QOS itself.\n\nMaxJobsAccruePerAccount\n\nThe maximum number of pending jobs an\n  account (or sub-account) can have accruing age priority at any given time.\n  This limit does not determine if the job can run, it only limits the\n  age factor of the priority.\n\nMaxJobsAccruePerUser\n\nThe maximum number of pending jobs a\n  user can have accruing age priority at any given time.\n  This limit does not determine if the job can run, it only limits the\n  age factor of the priority.\n\nMaxJobsPerAccount\n\nThe maximum number of jobs an account (or sub-account) can have running at\n  a given time.\n\nMaxJobsPerUser\n\nThe maximum number of jobs a user can\n  have running at a given time.\n\nMaxSubmitJobsPerAccount\n\nThe maximum number of jobs an account (or sub-account) can have running and\n  pending at a given time.\n\nMaxSubmitJobsPerUser\n\nThe maximum number of jobs a user can\n  have running and pending at a given time.\n\nMaxTRESMinsPerJob\n\nMaximum number of TRES minutes each job is able to use.\n\nMaxTRESPerAccount\n\nThe maximum number of TRES an account can\n  allocate at a given time.\n\nMaxTRESPerJob\n\nThe maximum number of TRES each job is able to use.\n\nMaxTRESPerNode\n\nThe maximum number of TRES each node in a job allocation can use.\n\nMaxTRESPerUser\n\nThe maximum number of TRES a user can\n  allocate at a given time.\n\nMaxWallDurationPerJob\n\nMaximum wall clock time each job is able to use. Format is <min>\n  or <min>:<sec> or <hr>:<min>:<sec> or\n  <days>-<hr>:<min>:<sec> or <days>-<hr>.\n  The value is recorded in minutes with rounding as needed.\n\nMinPrioThreshold\n\nMinimum priority required to reserve resources when scheduling.\n\nMinTRESPerJob\n\nThe minimum size in TRES any given job can\n  have when using the requested QOS.\n\nUsageFactor\n\nA float that is factored into a job's TRES usage (e.g. RawUsage,\n  TRESMins, TRESRunMins). For example, if the usagefactor was 2, for every\n  TRESBillingUnit second a job ran it would count for 2. If the usagefactor\n  was .5, every second would only count for half of the time.\n  A setting of 0 would add no timed usage from the job.\n\n  The usage factor only applies to the job's QOS and not the partition QOS.\n  \n  If the UsageFactorSafe flag is set and AccountingStorageEnforce includes\n  Safe, jobs will only be able to run if the job can run to completion\n  with the UsageFactor applied, and won't be killed due to limits.\n  \n  If the UsageFactorSafe flag is not set and AccountingStorageEnforce includes\n  Safe, a job will be able to be scheduled without the UsageFactor\n  applied and won't be killed due to limits.\n  \n  If the UsageFactorSafe flag is not set and AccountingStorageEnforce does\n  not include Safe, a job will be scheduled as long as the limits are\n  not reached, but could be killed due to limits.\n  \n  See \n  AccountingStorageEnforce in the slurm.conf man page.\n\nThe MaxNodes and MaxTime options already exist in\nSlurm's configuration on a per-partition basis, but the above options\nprovide the ability to impose limits on a per-user basis.  The\nMaxJobs option provides an entirely new mechanism for Slurm to\ncontrol the workload any individual may place on a cluster in order to\nachieve some balance between users.When assigning limits to a QOS to use for a Partition QOS,\nkeep in mind that those limits are enforced at the QOS level, not\nindividually for each partition.  For example, if a QOS has a\nGrpTRES=cpu=20 limit defined and the QOS is assigned to two\nunique partitions, users will be limited to 20 CPUs for the QOS\nrather than being allowed 20 CPUs for each partition.Fair-share scheduling is based upon the hierarchical bank account\ndata maintained in the Slurm database.  More information can be found\nin the priority/multifactor\nplugin description.Specific limits over GRES\n\n When a GRES has a type associated with it and a limit is applied\n  over this specific type (e.g. MaxTRESPerUser=gres/gpu:tesla=1) if a\n  user requests a generic gres, the type's limit will not be enforced. In this\n  situation an additional lua job submit plugin to check the user request may\n  become useful. For example, if one requests --gres=gpu:2 having a\n  limit set of MaxTRESPerUser=gres/gpu:tesla=1, the limit won't be\n  enforced so it will still be possible to get two teslas.\n\n  This is due to a design limitation. The only way to enforce such a limit\n  is to combine the specification of the limit with a job submit plugin that\n  forces the user to always request a specific type model.\n\n  An example of basic lua job submit plugin function could be:\n\nfunction slurm_job_submit(job_desc, part_list, submit_uid)\n   gres_request = \"\"\n   t = {job_desc.tres_per_job,\n\tjob_desc.tres_per_socket,\n\tjob_desc.tres_per_task,\n\tjob_desc.tres_per_node}\n   for k in pairs(t) do\n\tgres_request = gres_request .. t[k] .. \",\"\n   end\n   if (gres_request ~= nil)\n   then\n      for g in gres_request:gmatch(\"[^,]+\")\n      do\n\t bad = string.match(g,'^gres/gpu[:=]*[0-9]*$')\n\t if (bad ~= nil)\n\t then\n\t    slurm.log_info(\"User specified gpu GRES without type: %s\", bad)\n\t    slurm.user_msg(\"You must always specify a type when requesting gpu GRES\")\n\t    return slurm.ERROR\n\t end\n      end\n   end\nend\n Having this script and the limit in place will force the users to always\n  specify a gpu with its type, thus enforcing the limits for each specific\n  model.\nWhen TRESBillingWeights are defined for a partition, both typed and\nnon-typed resources should be included. For example, if you have 'tesla' GPUs\nin one partition and you only define the billing weights for the 'tesla' typed\nGPU resource, then those weights will not be applied to the generic GPUs.It is also advisable to set AccountingStorageTRES for both generic\n  and specific gres types, otherwise requests that ask for the generic instance\n  of a gres won't be accounted for. For example, to track generic GPUs and\n  Tesla GPUs, you would set this in your slurm.conf:\n\n  AccountingStorageTRES=gres/gpu,gres/gpu:tesla\n\n  See Trackable Resources TRES for details.\nJob Reason Codes\n\nWhen a pending job is evaluated by the scheduler but found to exceed a\nconfigured resource limit, a corresponding reason will be assigned to the job.\nMore details can be found on the Job Reason\nCodes page. More details about scheduling can be found in the\n Scheduling Configuration Guide.Last modified 27 September 2024\n"
        }
    ]
}