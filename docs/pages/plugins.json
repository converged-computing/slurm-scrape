{
    "url": "https://slurm.schedmd.com/plugins.html",
    "sections": [
        {
            "title": "\n\nSlurm Workload Manager\n\n",
            "content": "\n\nSchedMD\n\n"
        },
        {
            "title": "Slurm Plugin API",
            "content": "OverviewA Slurm plugin is a dynamically linked code object which is loaded explicitly\nat run time by the Slurm libraries. A plugin provides a customized implementation\nof a well-defined API connected to tasks such as authentication, interconnect\nfabric, and task scheduling.Identification\nA Slurm plugin identifies itself by a short character string formatted similarly\nto a MIME type: <major>/<minor>. The major type identifies\nwhich API the plugin implements. The minor type uniquely distinguishes a plugin\nfrom other plugins that implement that same API, by such means as the intended\nplatform or the internal algorithm. For example, a plugin to interface to the\nMaui scheduler would give its type as \"sched/maui.\" It would implement\nthe Slurm Scheduler API.Versioning\n\nSlurm plugin version numbers comprise a major, minor and micro revision number.\nIf the major and/or minor revision number changes, this indicates major changes\nto the Slurm functionality including changes to APIs, command options, and\nplugins.\nThese plugin changes may include new functions and/or function arguments.\nIf only the micro revision number changes, this is indicative of bug fixes\nand possibly minor enhancements which should not adversely impact users.\nIn all cases, rebuilding and installing all Slurm plugins is recommended\nat upgrade time.\nNot all compute nodes in a cluster need be updated at the same time, but\nall Slurm APIs, commands, plugins, etc. on a compute node should represent\nthe same version of Slurm.Data Objects\nA plugin must define and export the following symbols:\nchar plugin_type[]\nA unique, short, formatted string to identify the plugin's purpose as\ndescribed above. A \"null\" plugin (i.e., one that implements the desired\nAPI as stubs) should have a minor type of \"none.\"\nchar plugin_name[]\nA free-form string that identifies the plugin in human-readable terms,\nsuch as \"Kerberos authentication.\" Slurm will use this string to identify\nthe plugin to end users.\nconst uint32_t plugin_version\nIdentifies the version of Slurm used to build this plugin and\nany attempt to load the plugin from a different version of Slurm will result\nin an error.\nThe micro version is not considered for SPANK plugins.\nAPI Functions in All Plugins\n\nint init (void);Description: If present, this function is called\njust after the plugin is loaded. This allows the plugin to perform any global\ninitialization prior to any actual API calls.Arguments: None.Returns: SLURM_SUCCESS if the plugin's initialization\nwas successful. Any other return value indicates to Slurm that the plugin should\nbe unloaded and not used.void fini (void);Description: If present, this function is called\njust before the plugin is unloaded. This allows the plugin to do any finalization\nafter the last plugin-specific API call is made.Arguments: None.Returns: None.Note: These init and fini functions are not the same as those\ndescribed in the dlopen (3) system library.\nThe C run-time system co-opts those symbols for its own initialization.\nThe system _init() is called before the Slurm\ninit(), and the Slurm\nfini() is called before the system's\n_fini().The functions need not appear. The plugin may provide either\ninit() or fini() or both.Thread Safety\n\nSlurm is a multithreaded application. The Slurm plugin library may exercise\nthe plugin functions in a re-entrant fashion. It is the responsibility of the\nplugin author to provide the necessarily mutual exclusion and synchronization\nin order to avoid the pitfalls of re-entrant code.Run-time Support\n\nThe standard system libraries are available to the plugin. The Slurm libraries\nare also available and plugin authors are encouraged to make use of them rather\nthan develop their own substitutes. Plugins should use the Slurm log to print\nerror messages.The plugin author is responsible for specifying any specific non-standard libraries\nneeded for correct operation. Plugins will not load if their dependent libraries\nare not available, so it is the installer's job to make sure the specified libraries\nare available.Performance\n\nAll plugin functions are expected to execute very quickly. If any function\nentails delays (e.g. transactions with other systems), it should be written to\nutilize a thread for that functionality. This thread may be created by the\ninit() function and deleted by the\nfini() functions. See plugins/sched/backfill\nfor an example of how to do this.Data Structure Consistency\n\n\n  In certain situations Slurm iterates over different data structures elements\n  using counters. For example, with environment variable arrays.\n  In order to avoid buffer overflows and other undesired situations, when a\n  plugin modifies certain elements it must also update these counters accordingly.\n  Other situations may require other types of changes.\n\n  The following advice indicates which structures have arrays with associated\n  counters that must be maintained when modifying data, plus other possible\n  important information to take in consideration when manipulating these\n  structures.\n  This list is not fully exhaustive due to constant modifications in code,\n  but it is a first start point and basic guideline for most common situations.\n  Complete structure information can be seen in the slurm/slurm.h.in\n  file.\nslurm_job_info_t (job_info_t) Data Structure\n\n\n  uint32_t env_size;\n  char **environment;\n\n  uint32_t spank_job_env_size;\n  char **spank_job_env;\n\n  uint32_t gres_detail_cnt;\n  char **gres_detail_str;\n\n  These pairs of array pointers and element counters must kept updated in order\n  to avoid subsequent buffer overflows, so if you update the array you must\n  also update the related counter.\n\n  char *nodes;\n  int32_t *node_inx;\n\n  int32_t *req_node_inx;\n  char *req_nodes;\n\nnode_inx and req_node_inx represents a list of index pairs for\n  ranges of nodes defined in the nodes and req_nodes fields\n  respectively. In each case, both array variables must match the count.\n\n  uint32_t het_job_id;\n  char *het_job_id_set;\n\n  The het_job_id field should be the first element of the\n  het_job_id_set array.\njob_step_info_t Data Structure\n\n\n  char *nodes;\n  int32_t *node_inx;\n\nnode_inx represents a list of index pairs for range of nodes defined in\n  nodes. Both variables must match the node count.\npriority_factors_object_t Data Structure\n\n\n  uint32_t tres_cnt;\n  char **tres_names;\n  double *tres_weights;\n\n  This value must match the configured TRES on the system, otherwise\n  iteration over the tres_names or tres_weights arrays can cause\n  buffer overflows.\njob_step_pids_t Data Structure\n\n\n  uint32_t pid_cnt;\n  uint32_t *pid;\n\n  Array pid represents the list of Process IDs for the job step, and\n  pid_cnt is the counter that must match the size of the array.\nslurm_step_layout_t Data Structure\n\n\n  uint32_t node_cnt;\n  char *node_list;\n\n  The node_list array size must match node_cnt.\n\n  uint16_t *tasks;\n  uint32_t node_cnt;\n  uint32_t task_cnt;\n\n  In the tasks array, each element is the number of tasks assigned\n  to the corresponding node, to its size must match node_cnt. Moreover\n  task_cnt represents the sum of tasks registered in tasks.\n\n  uint32_t **tids;\n\ntids is an array of length node_cnt of task ID arrays. Each\n  subarray is designated by the corresponding value in the tasks array,\n  so tasks, tids and task_cnt must be set to match this\n  layout.\nslurm_step_launch_params_t Data Structure\n\n\n  uint32_t envc;\n  char **env;\n\n  When modifying the environment variables in the env array, you must\n  also modify the envc counter accordingly to prevent buffer overflows\n  in subsequent loops over that array.\n\n  uint32_t het_job_nnodes;\n  uint32_t het_job_ntasks;\n\n  uint16_t *het_job_task_cnts;\n  uint32_t **het_job_tids;\n  uint32_t *het_job_node_list;\n\n  This het_job_* related variables must match the current heterogeneous\n  job configuration.\n  \n  For example, if for whatever reason you are reducing the number of tasks for\n  a node in a heterogeneous job, you should at least remove that task ID from\n  het_job_tids, decrement het_job_ntasks and\n  het_job_task_cnts, and possibly decrement the number of nodes of the\n  heterogeneous job in het_job_nnodes and het_job_node_list.\n\n  char **spank_job_env;\n  uint32_t spank_job_env_size;\n\n  When modifying the spank_job_env structure, the\n  spank_job_env_size field must be updated to prevent buffer overflows\n  in subsequent loops over that array.\nnode_info_t Data Structure\n\n\n  char *features;\n  char *features_act;\n\n  In a system containing Intel KNL processors the features_act field is\n  set by the plugin to match the currently running modes on the node. On other\n  systems the features_act is not usually used.\n  If you program such a plugin you must ensure that features_act contains\n  a subset of features.\n\nchar *reason;\ntime_t reason_time;\nuint32_t reason_uid;\n\n  If reason is modified then reason_time and reason_uid\n  should be updated.\nreserve_info_t Data Structure\n\n\n  int32_t *node_inx;\n  uint32_t node_cnt;\n\nnode_inx represents a list of index pairs for range of nodes associated\n  with the reservation and its count must equal node_cnt.\npartition_info_t Data Structure\n\n\n  No special advice.\nslurm_step_layout_req_t Data Structure\n\n\n  No special advice.\nslurm_step_ctx_params_t\n\n\n  No special advice.\nLast modified 25 August 2022"
        },
        {
            "title": "Navigation",
            "content": "\nSlurm Workload Manager\nVersion 24.05\n\n\nAbout\n\nOverview\nRelease Notes\n\n\n\nUsing\n\nDocumentation\nFAQ\nPublications\n\n\n\nInstalling\n\nDownload\nRelated Software\nInstallation Guide\n\n\n\nGetting Help\n\nMailing Lists\nSupport and Training\nTroubleshooting\n\n\n"
        }
    ]
}