{
    "url": "https://slurm.schedmd.com/mc_support.html",
    "sections": [
        {
            "title": "\n\nSlurm Workload Manager\n\n",
            "content": "\n\nSchedMD\n\n"
        },
        {
            "title": "Support for Multi-core/Multi-thread Architectures",
            "content": "Contents\n Definitions\n Overview of srun flags\n Motivation behind high-level srun flags\n Extensions to sinfo/squeue/scontrol\n Configuration settings in slurm.conf\nDefinitions\nBaseBoard\nAlso called motherboard.\nLDom\nLocality domain or NUMA domain. May be equivalent to BaseBoard or Socket.\nSocket/Core/Thread\nFigure 1 illustrates the notion of Socket, Core and Thread as it is defined\nin Slurm's multi-core/multi-thread support documentation.\nCPU\nDepending upon system configuration, this can be either a core or a thread.\n\n\n\nFigure 1: Definitions of Socket, Core, & Thread\n\nAffinity\nThe state of being bound to a specific logical processor.\nAffinity Mask\nA bitmask where indices correspond to logical processors.\nThe least significant bit corresponds to the first\nlogical processor number on the system, while the most\nsignificant bit corresponds to the last logical processor\nnumber on the system.\nA '1' in a given position indicates a process can run\non the associated logical processor.\nFat Masks\nAffinity masks with more than 1 bit set\nallowing a process to run on more than one logical processor.\nOverview of srun flags\n\nMany flags have been defined to allow users to\nbetter take advantage of this architecture by\nexplicitly specifying the number of sockets, cores, and threads required\nby their application.  Table 1 summarizes these options.\n\n\n\n\nLow-level (explicit binding)\n\n\n --cpu-bind=... \nExplicit process affinity binding and control options\n\n\nHigh-level (automatic mask generation)\n\n\n --sockets-per-node=S\nNumber of sockets in a node to dedicate to a job (minimum)\n\n\n --cores-per-socket=C\n Number of cores in a socket to dedicate to a job (minimum)\n\n\n --threads-per-core=T\n Minimum number of threads in a core to dedicate to a job. In task\n\t layout, use the specified maximum number of threads per-core.\n\n\n -B S[:C[:T]]\n Combined shortcut option for --sockets-per-node, --cores-per_cpu, --threads-per_core\n\n\nTask Distribution Options\n\n\n -m / --distribution \n Distributions of: arbitrary | block | cyclic\n    \t\t| plane=x\n\t\t| [block|cyclic]:[block|cyclic|fcyclic]\n\n\nMemory as a consumable resource\n\n\n --mem=mem\n amount of real memory per node required by the job.\n\n\n --mem-per-cpu=mem\n amount of real memory per allocated CPU required by the job.\n\n\nTask invocation control\n\n\n --cpus-per-task=CPUs\n number of CPUs required per task\n\n --ntasks-per-node=ntasks\n number of tasks to invoke on each node\n\n --ntasks-per-socket=ntasks\n number of tasks to invoke on each socket\n\n --ntasks-per-core=ntasks\n number of tasks to invoke on each core\n\n --overcommit\n Permit more than one task per CPU\n\n\nApplication hints\n\n\n --hint=compute_bound\n use all cores in each socket\n\n --hint=memory_bound\n use only one core in each socket\n\n --hint=[no]multithread\n [don't] use extra threads with in-core multi-threading\n\n\nResources reserved for system use\n\n\n --core-spec=cores\n Count of cores to reserve for system use\n\n --thread-spec=threads\n Count of threads to reserve for system use\n\n\n\n\nTable 1: srun flags to support the multi-core/multi-threaded environment\n\nIt is important to note that many of these flags are only meaningful if the\nprocesses have some affinity to specific CPUs and (optionally) memory.\nInconsistent options generally result in errors.\nTask affinity is configured using the TaskPlugin parameter in the slurm.conf file.\nSeveral options exist for the TaskPlugin depending upon system architecture\nand available software, any of them except \"task/none\" will bind tasks to CPUs.\nSee the \"Task Launch\" section if generating slurm.conf via\nconfigurator.html.\nLow-level --cpu-bind=... - Explicit binding interface\n\n\nThe following srun flag provides a low-level core binding interface:\n\n--cpu-bind=        Bind tasks to CPUs\n    q[uiet]         quietly bind before task runs (default)\n    v[erbose]       verbosely report binding before task runs\n    no[ne]          don't bind tasks to CPUs (default)\n    rank            bind by task rank\n    map_cpu:<list>  specify a CPU ID binding for each task\n                    where <list> is\n                    <cpuid1>,<cpuid2>,...<cpuidN>\n    mask_cpu:<list> specify a CPU ID binding mask for each\n                    task where <list> is\n                    <mask1>,<mask2>,...<maskN>\n    rank_ldom       bind task by rank to CPUs in a NUMA\n                    locality domain\n    map_ldom:<list> specify a NUMA locality domain ID\n                    for each task where <list> is\n                    <ldom1>,<ldom2>,...<ldomN>\n    rank_ldom       bind task by rank to CPUs in a NUMA\n                    locality domain where <list> is\n                    <ldom1>,<ldom2>,...<ldomN>\n    mask_ldom:<list> specify a NUMA locality domain ID mask\n                    for each task where <list> is\n                    <ldom1>,<ldom2>,...<ldomN>\n    ldoms           auto-generated masks bind to NUMA locality\n                    domains\n    sockets         auto-generated masks bind to sockets\n    cores           auto-generated masks bind to cores\n    threads         auto-generated masks bind to threads\n    help            show this help message\n\n The affinity can be either set to either a specific logical processor\n(socket, core, threads) or at a coarser granularity than the lowest level\nof logical processor (core or thread).\nIn the later case the processes are allowed to utilize multiple processors\nwithin a specific socket or core.\n\nExamples:\n\n\n srun -n 8 -N 4 --cpu-bind=mask_cpu:0x1,0x4 a.out\n srun -n 8 -N 4 --cpu-bind=mask_cpu:0x3,0xD a.out\n\n\nSee also 'srun --cpu-bind=help' and 'man srun'\n\nHigh-level -B S[:C[:T]] - Automatic mask generation interface\n\n\nWe have updated the node\nselection infrastructure with a mechanism that allows selection of logical\nprocessors at a finer granularity. Users are able to request a specific number\nof nodes, sockets,\u00a0 cores, and threads:\n\n-B, --extra-node-info=S[:C[:T]]            Expands to:\n  --sockets-per-node=S   number of sockets per node to allocate\n  --cores-per-socket=C   number of cores per socket to allocate\n  --threads-per-core=T   number of threads per core to allocate\n                each field can be 'min' or wildcard '*'\n\n     Total cpus requested = (Nodes) x (S x C x T)\n\nExamples:\n\n\n\n srun -n 8 -N 4 -B 2:1 a.out\n srun -n 8 -N 4 -B 2   a.out\n\nnote: compare the above with the previous corresponding --cpu-bind=... examples\n\n srun -n 16 -N 4 a.out\n srun -n 16 -N 4 -B 2:2:1 a.out\n srun -n 16 -N 4 -B 2:2:1 a.out\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0or\n srun -n 16 -N 4 --sockets-per-node=2 --cores-per-socket=2 --threads-per-core=1 a.out\n srun -n 16 -N 2-4 -B '1:*:1' a.out\n srun -n 16 -N 4-2 -B '2:*:1' a.out\n srun -n 16 -N 4-4 -B '1:1' a.out\n\n\nNotes:\n\n Adding --cpu-bind=no to the command line will cause the processes\n      to not be bound the logical processors.\n  Adding --cpu-bind=verbose to the command line (or setting the\n      CPU_BIND environment variable to \"verbose\") will cause each task\n      to report the affinity mask in use\n  Binding is on by default when -B is used. The default binding on\n      multi-core/multi-threaded systems is equivalent to the level of\n      resource enumerated in the -B option.\n\nSee also 'srun --help' and 'man srun'\nTask distribution options: Extensions to -m / --distribution\n\n\nThe -m / --distribution option for distributing processes across nodes\nhas been extended to also describe the distribution within the lowest level\nof logical processors.\nAvailable distributions include:\n\narbitrary | block | cyclic | plane=x | [block|cyclic]:[block|cyclic|fcyclic]\n\nThe  plane distribution (plane=x)\nresults in a block:cyclic distribution of blocksize equal to x.\nIn the following we use \"lowest level of logical processors\"\nto describe sockets, cores or threads depending of the architecture.\nThe distribution divides\nthe cluster into planes (including a number of the lowest level of logical\nprocessors on each node) and then schedule first within each plane and then\nacross planes.\nFor the two dimensional distributions ([block|cyclic]:[block|cyclic|fcyclic]),\nthe second distribution (after \":\") allows users to specify a distribution\nmethod for processes within a node and applies to the lowest level of logical\nprocessors (sockets, core or thread depending on the architecture).\nWhen a task requires more than one CPU, the cyclic will allocate all\nof those CPUs as a group (i.e. within the same socket if possible) while \nfcyclic would distribute each of those CPU of the in a cyclic fashion\nacross sockets.\nThe binding is enabled automatically when high level flags are used as long\nas the task/affinity plug-in is enabled. To disable binding at the job level\nuse --cpu-bind=no.\nThe distribution flags can be combined with the other switches:\n\n\n\nsrun -n 16 -N 4 -B '2:*:1' -m block:cyclic --cpu-bind=socket a.out\nsrun -n 16 -N 4 -B '2:*:1' -m plane=2 --cpu-bind=core a.out\nsrun -n 16 -N 4 -B '2:*:1' -m plane=2 a.out\n\n\nThe default distribution on multi-core/multi-threaded systems is equivalent\nto -m block:cyclic with --cpu-bind=thread.\nSee also 'srun --help'\nMemory as a Consumable Resource\n\n\nThe --mem flag specifies the maximum amount of memory in MB\nneeded by the job per node.  This flag is used to support the memory\nas a consumable resource allocation strategy.\n\n--mem=MB      maximum amount of real memory per node\n              required by the job.\n\nThis flag allows the scheduler to co-allocate jobs on specific nodes\ngiven that their added memory requirement do not exceed the total amount\nof memory on the nodes.\nIn order to use memory as a consumable resource, the select/cons_tres\nplugin must be first enabled in slurm.conf:\n\nSelectType=select/cons_tres     # enable consumable resources\nSelectTypeParameters=CR_Memory  # memory as a consumable resource\n\n Using memory as a consumable resource is typically combined with\nthe CPU, Socket, or Core consumable resources using SelectTypeParameters\nvalues of: CR_CPU_Memory, CR_Socket_Memory or CR_Core_Memory\n\nSee the \"Resource Selection\" section if generating slurm.conf\nvia configurator.html.\n\nSee also 'srun --help' and 'man srun'\nTask invocation as a function of logical processors\n\n\nThe --ntasks-per-{node,socket,core}=ntasks flags\nallow the user to request that no more than ntasks\nbe invoked on each node, socket, or core.\nThis is similar to using --cpus-per-task=ncpus\nbut does not require knowledge of the actual number of cpus on\neach node.  In some cases, it is more convenient to be able to\nrequest that no more than a specific number of ntasks be invoked\non each node, socket, or core.  Examples of this include submitting\nan app where only one \"task/rank\" should be\nassigned to each node while allowing the job to utilize\nall of the parallelism present in the node, or submitting a single\nsetup/cleanup/monitoring job to each node of a pre-existing\nallocation as one step in a larger job script.\nThis can now be specified via the following flags:\n\n--ntasks-per-node=n    number of tasks to invoke on each node\n--ntasks-per-socket=n  number of tasks to invoke on each socket\n--ntasks-per-core=n    number of tasks to invoke on each core\n\nFor example, given a cluster with nodes containing two sockets,\neach containing two cores, the following commands illustrate the\nbehavior of these flags:\n\n% srun -n 4 hostname\nhydra12\nhydra12\nhydra12\nhydra12\n% srun -n 4 --ntasks-per-node=1 hostname\nhydra12\nhydra13\nhydra14\nhydra15\n% srun -n 4 --ntasks-per-node=2 hostname\nhydra12\nhydra12\nhydra13\nhydra13\n% srun -n 4 --ntasks-per-socket=1 hostname\nhydra12\nhydra12\nhydra13\nhydra13\n% srun -n 4 --ntasks-per-core=1 hostname\nhydra12\nhydra12\nhydra12\nhydra12\n\nSee also 'srun --help' and 'man srun'\nApplication hints\n\n\nDifferent applications will have various levels of resource\nrequirements. Some applications tend to be computationally intensive\nbut require little to no inter-process communication. Some applications\nwill be memory bound, saturating the memory bandwidth of a processor\nbefore exhausting the computational capabilities. Other applications\nwill be highly communication intensive causing processes to block\nawaiting messages from other processes. Applications with these\ndifferent properties tend to run well on a multi-core system given\nthe right mappings.\nFor computationally intensive applications, all cores in a multi-core\nsystem would normally be used. For memory bound applications, only\nusing a single core on each socket will result in the highest per\ncore memory bandwidth. For communication intensive applications,\nusing in-core multi-threading (e.g. hyperthreading, SMT, or TMT)\nmay also improve performance.\nThe following command line flags can be used to communicate these\ntypes of application hints to the Slurm multi-core support:\n\n--hint=             Bind tasks according to application hints\n    compute_bound   use all cores in each socket\n    memory_bound    use only one core in each socket\n    [no]multithread [don't] use extra threads with in-core multi-threading\n    help            show this help message\n\nFor example, given a cluster with nodes containing two sockets,\neach containing two cores, the following commands illustrate the\nbehavior of these flags.  In the verbose --cpu-bind output, tasks\nare described as 'hostname, task Global_ID Local_ID [PID]':\n\n% srun -n 4 --hint=compute_bound --cpu-bind=verbose sleep 1\ncpu-bind=MASK - hydra12, task  0  0 [15425]: mask 0x1 set\ncpu-bind=MASK - hydra12, task  1  1 [15426]: mask 0x4 set\ncpu-bind=MASK - hydra12, task  2  2 [15427]: mask 0x2 set\ncpu-bind=MASK - hydra12, task  3  3 [15428]: mask 0x8 set\n\n% srun -n 4 --hint=memory_bound --cpu-bind=verbose sleep 1\ncpu-bind=MASK - hydra12, task  0  0 [15550]: mask 0x1 set\ncpu-bind=MASK - hydra12, task  1  1 [15551]: mask 0x4 set\ncpu-bind=MASK - hydra13, task  2  0 [14974]: mask 0x1 set\ncpu-bind=MASK - hydra13, task  3  1 [14975]: mask 0x4 set\n\nSee also 'srun --hint=help' and 'man srun'\n\nMotivation behind high-level srun flags\n\n\nThe motivation behind allowing users to use higher level srun\nflags instead of --cpu-bind is that the later can be difficult to use. The\nproposed high-level flags are easier to use than --cpu-bind because:\n\nAffinity mask generation happens automatically when using the high-level flags. \nThe length and complexity of the --cpu-bind flag vs. the length\nof the combination of -B and --distribution flags make the high-level\nflags much easier to use.\n\nAlso as illustrated in the example below it is much simpler to specify\na different layout using the high-level flags since users do not have to\nrecalculate mask or CPU IDs. This approach is much simpler than\nrearranging the mask or map.\nGiven a 32-process job and a four node, dual-socket, dual-core\ncluster, we want to use a block distribution across the four nodes and then a\ncyclic distribution within the node across the physical processors. Below we\nshow how to obtain the wanted layout using 1) high-level flags and\n2) --cpubind\nHigh-Level flags\n\n\nUsing Slurm's high-level flag, users can obtain the above layout with\neither of the following submissions since --distribution=block:cyclic\nis the default distribution method.\n\n$ srun -n 32 -N 4 -B 4:2 --distribution=block:cyclic a.out\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0or\n\n$ srun -n 32 -N 4 -B 4:2 a.out\n\nThe cores are shown as c0 and c1 and the processors are shown\nas p0 through p3. The resulting task IDs are: \n\n\n\n\n \nc0c1\np0 0  4 \np2 2  6 \n\n\n\n\n\n\n \nc0c1\np1 1  5 \np3 3  7 \n\n\n\n\nThe computation and assignment of the task IDs is transparent\nto the user. Users don't have to worry about the core numbering (Section\nPinning processes to cores) or any setting any CPU affinities. By default CPU affinity\nwill be set when using multi-core supporting flags. \nLow-level flag --cpu-bind\n\n\nUsing Slurm's --cpu-bind flag, users must compute the CPU IDs or\nmasks as well as make sure they understand the core numbering on their\nsystem. Another problem arises when core numbering is not the same on all\nnodes. The --cpu-bind option only allows users to specify a single\nmask for all the nodes. Using Slurm high-level flags remove this limitation\nsince Slurm will correctly generate the appropriate masks for each requested nodes.\n\nOn a four dual-socket dual-core node cluster with core block numbering\n\n\nThe cores are shown as c0 and c1 and the processors are shown\nas p0 through p3. The CPU IDs within a node in the block numbering are:\n(this information is available from the /proc/cpuinfo file on the system)\n\n\n\n\n \nc0c1\np0 0  1 \np2 4  5 \n\n\n\n\n\n\n \nc0c1\np1 2  3 \np3 6  7 \n\n\n\n\n\u00a0resulting in the following mapping for processor/cores\nand task IDs which users need to calculate: \n\nmapping for processors/cores\n\n\n\n\n\n \nc0c1\np0 0x01  0x02 \np2 0x10  0x20 \n\n\n\n\n\n\n \nc0c1\np1 0x04  0x08 \np3 0x40  0x80 \n\n\n\n\n\n\ntask IDs\n\n\n\n\n\n \nc0c1\np0 0  4 \np2 2  6 \n\n\n\n\n\n\n \nc0c1\np1 1  5 \np3 3  7 \n\n\n\n\nThe above maps and task IDs can be translated into the\nfollowing command:\n\n$ srun -n 32 -N 4 --cpu-bind=mask_cpu:1,4,10,40,2,8,20,80 a.out\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0or\n\n$ srun -n 32 -N 4 --cpu-bind=map_cpu:0,2,4,6,1,3,5,7 a.out\n\n\nSame cluster but with its core numbered cyclic instead of block\n\n\nOn a system with cyclically numbered cores, the correct mask\nargument to the srun command looks like: (this will\nachieve the same layout as the command above on a system with core block\nnumbering.)\n\n$ srun -n 32 -N 4 --cpu-bind=map_cpu:0,1,2,3,4,5,6,7 a.out\n\nBlock map_cpu on a system with cyclic core numbering\n\n\nIf users do not check their system's core numbering before specifying\nthe map_cpu list and thereby do not realize that the system has cyclic core\nnumbering instead of block numbering then they will not get the expected\nlayout. For example, if they decide to re-use their command from above:\n\n$ srun -n 32 -N 4 --cpu-bind=map_cpu:0,2,4,6,1,3,5,7 a.out\n\nthey get the following unintentional task ID layout:\n\n\n\n\n \nc0c1\np0 0  2 \np2 1  3 \n\n\n\n\n\n\n \nc0c1\np1 4  6 \np3 5  7 \n\n\n\n\nsince the processor IDs within a node in the cyclic numbering are:\n\n\n\n\n \nc0c1\np0 0  4 \np2 2  6 \n\n\n\n\n\n\n \nc0c1\np1 1  5 \np3 3  7 \n\n\n\n\nThe important conclusion is that using the --cpu-bind flag is not\ntrivial and that it assumes that users are experts.\n\nExtensions to sinfo/squeue/scontrol\n\n\nSeveral extensions have also been made to the other Slurm utilities to\nmake working with multi-core/multi-threaded systems easier.\n\nsinfo\nThe long version (-l) of the sinfo node listing (-N) has been\nextended to display the sockets, cores, and threads present for each\nnode.  For example:\n\n\n% sinfo -N\nNODELIST     NODES PARTITION STATE\nhydra[12-15]     4    parts* idle\n\n% sinfo -lN\nThu Sep 14 17:47:13 2006\nNODELIST     NODES PARTITION       STATE CPUS    S:C:T MEMORY TMP_DISK WEIGHT FEATURES REASON\nhydra[12-15]     4    parts*        idle   8+ 2+:4+:1+   2007    41447      1   (null) none\n\n% sinfo -lNe\nThu Sep 14 17:47:18 2006\nNODELIST     NODES PARTITION       STATE CPUS    S:C:T MEMORY TMP_DISK WEIGHT FEATURES REASON\n\nhydra[12-14]     3    parts*        idle    8    2:4:1   2007    41447      1   (null) none\nhydra15          1    parts*        idle   64    8:4:2   2007    41447      1   (null) none\n\nFor user specified output formats (-o/--format) and sorting (-S/--sort),\nthe following identifiers are available:\n\n%X  Number of sockets per node\n%Y  Number of cores per socket\n%Z  Number of threads per core\n%z  Extended processor information: number of\n    sockets, core, threads (S:C:T) per node\n\nFor example:\n\n% sinfo -o '%9P %4c %8z %8X %8Y %8Z'\nPARTITION CPUS S:C:T    SOCKETS  CORES    THREADS\nparts*    4    2:2:1    2        2        1\n\nSee also 'sinfo --help' and 'man sinfo'\n\nsqueue\nFor user specified output formats (-o/--format) and sorting (-S/--sort),\nthe following identifiers are available:\n\n%m  Size of memory (in MB) requested by the job\n%H  Number of requested sockets per node\n%I  Number of requested cores per socket\n%J  Number of requested threads per core\n%z  Extended processor information: number of requested\n    sockets, cores, threads (S:C:T) per node\n\nBelow is an example squeue output after running 7 copies of:\n\n\n% srun -n 4 -B 2:2:1 --mem=1024 sleep 100 &\n\n\n\n% squeue -o '%.5i %.2t %.4M %.5D %7H %6I %7J %6z %R'\nJOBID ST TIME NODES SOCKETS CORES THREADS S:C:T NODELIST(REASON)\n   17 PD 0:00     1 2       2     1       2:2:1 (Resources)\n   18 PD 0:00     1 2       2     1       2:2:1 (Resources)\n   19 PD 0:00     1 2       2     1       2:2:1 (Resources)\n   13  R 1:27     1 2       2     1       2:2:1 hydra12\n   14  R 1:26     1 2       2     1       2:2:1 hydra13\n   15  R 1:26     1 2       2     1       2:2:1 hydra14\n   16  R 1:26     1 2       2     1       2:2:1 hydra15\n\nThe squeue command can also display the memory size of jobs, for example:\n\n% sbatch --mem=123 tmp\nSubmitted batch job 24\n\n$ squeue -o \"%.5i %.2t %.4M %.5D %m\"\nJOBID ST TIME NODES MIN_MEMORY\n  24   R 0:05     1 123\n\nSee also 'squeue --help' and 'man squeue'\n\nscontrol\nThe following job settings can be adjusted using scontrol:\n\n\nRequested Allocation:\n  ReqSockets=<count>  Set the job's count of required sockets\n  ReqCores=<count>    Set the job's count of required cores\n  ReqThreads=<count>  Set the job's count of required threads\n\nFor example:\n\n# scontrol update JobID=17 ReqThreads=2\n# scontrol update JobID=18 ReqCores=4\n# scontrol update JobID=19 ReqSockets=8\n\n% squeue -o '%.5i %.2t %.4M %.5D %9c %7H %6I %8J'\nJOBID ST TIME NODES MIN_PROCS SOCKETS CORES THREADS\n   17 PD 0:00     1 1         4       2     1\n   18 PD 0:00     1 1         8       4     2\n   19 PD 0:00     1 1         4       2     1\n   13  R 1:35     1 0         0       0     0\n   14  R 1:34     1 0         0       0     0\n   15  R 1:34     1 0         0       0     0\n   16  R 1:34     1 0         0       0     0\n\nThe 'scontrol show job' command can be used to display\nthe number of allocated CPUs per node as well as the socket, cores,\nand threads specified in the request and constraints.\n\n\n% srun -N 2 -B 2:1 sleep 100 &\n% scontrol show job 20\nJobId=20 UserId=(30352) GroupId=users(1051)\n   Name=sleep\n   Priority=4294901749 Partition=parts BatchFlag=0\n   AllocNode:Sid=hydra16:3892 TimeLimit=UNLIMITED\n   JobState=RUNNING StartTime=09/25-17:17:30 EndTime=NONE\n   NodeList=hydra[12-14] NodeListIndices=0,2,-1\n   AllocCPUs=1,2,1\n   NumCPUs=4 ReqNodes=2 ReqS:C:T=2:1:*\n   OverSubscribe=0 Contiguous=0 CPUs/task=0\n   MinCPUs=0 MinMemory=0 MinTmpDisk=0 Features=(null)\n   Dependency=0 Account=(null) Reason=None Network=(null)\n   ReqNodeList=(null) ReqNodeListIndices=-1\n   ExcNodeList=(null) ExcNodeListIndices=-1\n   SubmitTime=09/25-17:17:30 SuspendTime=None PreSusTime=0\n\nSee also 'scontrol --help' and 'man scontrol'\n\nConfiguration settings in slurm.conf\n\n\nSeveral slurm.conf settings are available to control the multi-core\nfeatures described above.\n\nIn addition to the description below, also see the \"Task Launch\" and\n\"Resource Selection\" sections if generating slurm.conf\nvia configurator.html.\n\nAs previously mentioned, in order for the affinity to be set, the\ntask/affinity plugin must be first enabled in slurm.conf:\n\n\nTaskPlugin=task/affinity          # enable task affinity\n\nThis setting is part of the task launch specific parameters:\n\n# o Define task launch specific parameters\n#\n#    \"TaskProlog\" : Define a program to be executed as the user before each\n#                   task begins execution.\n#    \"TaskEpilog\" : Define a program to be executed as the user after each\n#                   task terminates.\n#    \"TaskPlugin\" : Define a task launch plugin. This may be used to\n#                   provide resource management within a node (e.g. pinning\n#                   tasks to specific processors). Permissible values are:\n#      \"task/affinity\" : CPU affinity support\n#      \"task/cgroup\"   : bind tasks to resources using Linux cgroup\n#      \"task/none\"     : no task launch actions, the default\n#\n# Example:\n#\n# TaskProlog=/usr/local/slurm/etc/task_prolog # default is none\n# TaskEpilog=/usr/local/slurm/etc/task_epilog # default is none\n# TaskPlugin=task/affinity                    # default is task/none\n\nDeclare the node hardware configuration in slurm.conf:\n\n\nNodeName=dualcore[01-16] CoresPerSocket=2 ThreadsPerCore=1\n\nFor a more complete description of the various node configuration options\nsee the slurm.conf man page.\n\nLast modified 19 May 2023\n"
        },
        {
            "title": "Navigation",
            "content": "\nSlurm Workload Manager\nVersion 24.05\n\n\nAbout\n\nOverview\nRelease Notes\n\n\n\nUsing\n\nDocumentation\nFAQ\nPublications\n\n\n\nInstalling\n\nDownload\nRelated Software\nInstallation Guide\n\n\n\nGetting Help\n\nMailing Lists\nSupport and Training\nTroubleshooting\n\n\n"
        },
        {
            "title": "Motivation behind high-level srun flags\n\n",
            "content": "The motivation behind allowing users to use higher level srun\nflags instead of --cpu-bind is that the later can be difficult to use. The\nproposed high-level flags are easier to use than --cpu-bind because:\nAffinity mask generation happens automatically when using the high-level flags. \nThe length and complexity of the --cpu-bind flag vs. the length\nof the combination of -B and --distribution flags make the high-level\nflags much easier to use.\nAlso as illustrated in the example below it is much simpler to specify\na different layout using the high-level flags since users do not have to\nrecalculate mask or CPU IDs. This approach is much simpler than\nrearranging the mask or map.Given a 32-process job and a four node, dual-socket, dual-core\ncluster, we want to use a block distribution across the four nodes and then a\ncyclic distribution within the node across the physical processors. Below we\nshow how to obtain the wanted layout using 1) high-level flags and\n2) --cpubindHigh-Level flags\n\nUsing Slurm's high-level flag, users can obtain the above layout with\neither of the following submissions since --distribution=block:cyclic\nis the default distribution method.\n$ srun -n 32 -N 4 -B 4:2 --distribution=block:cyclic a.out\n\n$ srun -n 32 -N 4 -B 4:2 a.out\nThe cores are shown as c0 and c1 and the processors are shown\nas p0 through p3. The resulting task IDs are: \n\n\n\n \nc0c1\np0 0  4 \np2 2  6 \n\n\n\n\n\n\n \nc0c1\np1 1  5 \np3 3  7 \n\n\n\nThe computation and assignment of the task IDs is transparent\nto the user. Users don't have to worry about the core numbering (Section\nPinning processes to cores) or any setting any CPU affinities. By default CPU affinity\nwill be set when using multi-core supporting flags. Low-level flag --cpu-bind\n\nUsing Slurm's --cpu-bind flag, users must compute the CPU IDs or\nmasks as well as make sure they understand the core numbering on their\nsystem. Another problem arises when core numbering is not the same on all\nnodes. The --cpu-bind option only allows users to specify a single\nmask for all the nodes. Using Slurm high-level flags remove this limitation\nsince Slurm will correctly generate the appropriate masks for each requested nodes.\nOn a four dual-socket dual-core node cluster with core block numbering\n\nThe cores are shown as c0 and c1 and the processors are shown\nas p0 through p3. The CPU IDs within a node in the block numbering are:\n(this information is available from the /proc/cpuinfo file on the system)\n\n\n\n \nc0c1\np0 0  1 \np2 4  5 \n\n\n\n\n\n\n \nc0c1\np1 2  3 \np3 6  7 \n\n\n\n\u00a0resulting in the following mapping for processor/cores\nand task IDs which users need to calculate: \nmapping for processors/cores\n\n\n\n\n \nc0c1\np0 0x01  0x02 \np2 0x10  0x20 \n\n\n\n\n\n\n \nc0c1\np1 0x04  0x08 \np3 0x40  0x80 \n\n\n\n\n\ntask IDs\n\n\n\n\n\n \nc0c1\np0 0  4 \np2 2  6 \n\n\n\n\n\n\n \nc0c1\np1 1  5 \np3 3  7 \n\n\n\n\nThe above maps and task IDs can be translated into the\nfollowing command:\n\n$ srun -n 32 -N 4 --cpu-bind=mask_cpu:1,4,10,40,2,8,20,80 a.out\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0or\n\n$ srun -n 32 -N 4 --cpu-bind=map_cpu:0,2,4,6,1,3,5,7 a.out\n\n\nSame cluster but with its core numbered cyclic instead of block\n\n\nOn a system with cyclically numbered cores, the correct mask\nargument to the srun command looks like: (this will\nachieve the same layout as the command above on a system with core block\nnumbering.)\n\n$ srun -n 32 -N 4 --cpu-bind=map_cpu:0,1,2,3,4,5,6,7 a.out\n\nBlock map_cpu on a system with cyclic core numbering\n\n\nIf users do not check their system's core numbering before specifying\nthe map_cpu list and thereby do not realize that the system has cyclic core\nnumbering instead of block numbering then they will not get the expected\nlayout. For example, if they decide to re-use their command from above:\n\n$ srun -n 32 -N 4 --cpu-bind=map_cpu:0,2,4,6,1,3,5,7 a.out\n\nthey get the following unintentional task ID layout:\n\n\n\n\n \nc0c1\np0 0  2 \np2 1  3 \n\n\n\n\n\n\n \nc0c1\np1 4  6 \np3 5  7 \n\n\n\n\nsince the processor IDs within a node in the cyclic numbering are:\n\n\n\n\n \nc0c1\np0 0  4 \np2 2  6 \n\n\n\n\n\n\n \nc0c1\np1 1  5 \np3 3  7 \n\n\n\n\nThe important conclusion is that using the --cpu-bind flag is not\ntrivial and that it assumes that users are experts.\n\nExtensions to sinfo/squeue/scontrol\n\n\nSeveral extensions have also been made to the other Slurm utilities to\nmake working with multi-core/multi-threaded systems easier.\n\nsinfo\nThe long version (-l) of the sinfo node listing (-N) has been\nextended to display the sockets, cores, and threads present for each\nnode.  For example:\n\n\n% sinfo -N\nNODELIST     NODES PARTITION STATE\nhydra[12-15]     4    parts* idle\n\n% sinfo -lN\nThu Sep 14 17:47:13 2006\nNODELIST     NODES PARTITION       STATE CPUS    S:C:T MEMORY TMP_DISK WEIGHT FEATURES REASON\nhydra[12-15]     4    parts*        idle   8+ 2+:4+:1+   2007    41447      1   (null) none\n\n% sinfo -lNe\nThu Sep 14 17:47:18 2006\nNODELIST     NODES PARTITION       STATE CPUS    S:C:T MEMORY TMP_DISK WEIGHT FEATURES REASON\n\nhydra[12-14]     3    parts*        idle    8    2:4:1   2007    41447      1   (null) none\nhydra15          1    parts*        idle   64    8:4:2   2007    41447      1   (null) none\n\nFor user specified output formats (-o/--format) and sorting (-S/--sort),\nthe following identifiers are available:\n\n%X  Number of sockets per node\n%Y  Number of cores per socket\n%Z  Number of threads per core\n%z  Extended processor information: number of\n    sockets, core, threads (S:C:T) per node\n\nFor example:\n\n% sinfo -o '%9P %4c %8z %8X %8Y %8Z'\nPARTITION CPUS S:C:T    SOCKETS  CORES    THREADS\nparts*    4    2:2:1    2        2        1\n\nSee also 'sinfo --help' and 'man sinfo'\n\nsqueue\nFor user specified output formats (-o/--format) and sorting (-S/--sort),\nthe following identifiers are available:\n\n%m  Size of memory (in MB) requested by the job\n%H  Number of requested sockets per node\n%I  Number of requested cores per socket\n%J  Number of requested threads per core\n%z  Extended processor information: number of requested\n    sockets, cores, threads (S:C:T) per node\n\nBelow is an example squeue output after running 7 copies of:\n\n\n% srun -n 4 -B 2:2:1 --mem=1024 sleep 100 &\n\n\n\n% squeue -o '%.5i %.2t %.4M %.5D %7H %6I %7J %6z %R'\nJOBID ST TIME NODES SOCKETS CORES THREADS S:C:T NODELIST(REASON)\n   17 PD 0:00     1 2       2     1       2:2:1 (Resources)\n   18 PD 0:00     1 2       2     1       2:2:1 (Resources)\n   19 PD 0:00     1 2       2     1       2:2:1 (Resources)\n   13  R 1:27     1 2       2     1       2:2:1 hydra12\n   14  R 1:26     1 2       2     1       2:2:1 hydra13\n   15  R 1:26     1 2       2     1       2:2:1 hydra14\n   16  R 1:26     1 2       2     1       2:2:1 hydra15\n\nThe squeue command can also display the memory size of jobs, for example:\n\n% sbatch --mem=123 tmp\nSubmitted batch job 24\n\n$ squeue -o \"%.5i %.2t %.4M %.5D %m\"\nJOBID ST TIME NODES MIN_MEMORY\n  24   R 0:05     1 123\n\nSee also 'squeue --help' and 'man squeue'\n\nscontrol\nThe following job settings can be adjusted using scontrol:\n\n\nRequested Allocation:\n  ReqSockets=<count>  Set the job's count of required sockets\n  ReqCores=<count>    Set the job's count of required cores\n  ReqThreads=<count>  Set the job's count of required threads\n\nFor example:\n\n# scontrol update JobID=17 ReqThreads=2\n# scontrol update JobID=18 ReqCores=4\n# scontrol update JobID=19 ReqSockets=8\n\n% squeue -o '%.5i %.2t %.4M %.5D %9c %7H %6I %8J'\nJOBID ST TIME NODES MIN_PROCS SOCKETS CORES THREADS\n   17 PD 0:00     1 1         4       2     1\n   18 PD 0:00     1 1         8       4     2\n   19 PD 0:00     1 1         4       2     1\n   13  R 1:35     1 0         0       0     0\n   14  R 1:34     1 0         0       0     0\n   15  R 1:34     1 0         0       0     0\n   16  R 1:34     1 0         0       0     0\n\nThe 'scontrol show job' command can be used to display\nthe number of allocated CPUs per node as well as the socket, cores,\nand threads specified in the request and constraints.\n\n\n% srun -N 2 -B 2:1 sleep 100 &\n% scontrol show job 20\nJobId=20 UserId=(30352) GroupId=users(1051)\n   Name=sleep\n   Priority=4294901749 Partition=parts BatchFlag=0\n   AllocNode:Sid=hydra16:3892 TimeLimit=UNLIMITED\n   JobState=RUNNING StartTime=09/25-17:17:30 EndTime=NONE\n   NodeList=hydra[12-14] NodeListIndices=0,2,-1\n   AllocCPUs=1,2,1\n   NumCPUs=4 ReqNodes=2 ReqS:C:T=2:1:*\n   OverSubscribe=0 Contiguous=0 CPUs/task=0\n   MinCPUs=0 MinMemory=0 MinTmpDisk=0 Features=(null)\n   Dependency=0 Account=(null) Reason=None Network=(null)\n   ReqNodeList=(null) ReqNodeListIndices=-1\n   ExcNodeList=(null) ExcNodeListIndices=-1\n   SubmitTime=09/25-17:17:30 SuspendTime=None PreSusTime=0\n\nSee also 'scontrol --help' and 'man scontrol'\n\nConfiguration settings in slurm.conf\n\n\nSeveral slurm.conf settings are available to control the multi-core\nfeatures described above.\n\nIn addition to the description below, also see the \"Task Launch\" and\n\"Resource Selection\" sections if generating slurm.conf\nvia configurator.html.\n\nAs previously mentioned, in order for the affinity to be set, the\ntask/affinity plugin must be first enabled in slurm.conf:\n\n\nTaskPlugin=task/affinity          # enable task affinity\n\nThis setting is part of the task launch specific parameters:\n\n# o Define task launch specific parameters\n#\n#    \"TaskProlog\" : Define a program to be executed as the user before each\n#                   task begins execution.\n#    \"TaskEpilog\" : Define a program to be executed as the user after each\n#                   task terminates.\n#    \"TaskPlugin\" : Define a task launch plugin. This may be used to\n#                   provide resource management within a node (e.g. pinning\n#                   tasks to specific processors). Permissible values are:\n#      \"task/affinity\" : CPU affinity support\n#      \"task/cgroup\"   : bind tasks to resources using Linux cgroup\n#      \"task/none\"     : no task launch actions, the default\n#\n# Example:\n#\n# TaskProlog=/usr/local/slurm/etc/task_prolog # default is none\n# TaskEpilog=/usr/local/slurm/etc/task_epilog # default is none\n# TaskPlugin=task/affinity                    # default is task/none\n\nDeclare the node hardware configuration in slurm.conf:\n\n\nNodeName=dualcore[01-16] CoresPerSocket=2 ThreadsPerCore=1\n\nFor a more complete description of the various node configuration options\nsee the slurm.conf man page.\n\nLast modified 19 May 2023\n"
        },
        {
            "title": "Extensions to sinfo/squeue/scontrol\n\n",
            "content": "Several extensions have also been made to the other Slurm utilities to\nmake working with multi-core/multi-threaded systems easier.sinfoThe long version (-l) of the sinfo node listing (-N) has been\nextended to display the sockets, cores, and threads present for each\nnode.  For example:\n\n\n% sinfo -N\nNODELIST     NODES PARTITION STATE\nhydra[12-15]     4    parts* idle\n\n% sinfo -lN\nThu Sep 14 17:47:13 2006\nNODELIST     NODES PARTITION       STATE CPUS    S:C:T MEMORY TMP_DISK WEIGHT FEATURES REASON\nhydra[12-15]     4    parts*        idle   8+ 2+:4+:1+   2007    41447      1   (null) none\n\n% sinfo -lNe\nThu Sep 14 17:47:18 2006\nNODELIST     NODES PARTITION       STATE CPUS    S:C:T MEMORY TMP_DISK WEIGHT FEATURES REASON\n\nhydra[12-14]     3    parts*        idle    8    2:4:1   2007    41447      1   (null) none\nhydra15          1    parts*        idle   64    8:4:2   2007    41447      1   (null) none\n\nFor user specified output formats (-o/--format) and sorting (-S/--sort),\nthe following identifiers are available:\n\n%X  Number of sockets per node\n%Y  Number of cores per socket\n%Z  Number of threads per core\n%z  Extended processor information: number of\n    sockets, core, threads (S:C:T) per node\n\nFor example:\n\n% sinfo -o '%9P %4c %8z %8X %8Y %8Z'\nPARTITION CPUS S:C:T    SOCKETS  CORES    THREADS\nparts*    4    2:2:1    2        2        1\n\nSee also 'sinfo --help' and 'man sinfo'\n\nsqueue\nFor user specified output formats (-o/--format) and sorting (-S/--sort),\nthe following identifiers are available:\n\n%m  Size of memory (in MB) requested by the job\n%H  Number of requested sockets per node\n%I  Number of requested cores per socket\n%J  Number of requested threads per core\n%z  Extended processor information: number of requested\n    sockets, cores, threads (S:C:T) per node\n\nBelow is an example squeue output after running 7 copies of:\n\n\n% srun -n 4 -B 2:2:1 --mem=1024 sleep 100 &\n\n\n\n% squeue -o '%.5i %.2t %.4M %.5D %7H %6I %7J %6z %R'\nJOBID ST TIME NODES SOCKETS CORES THREADS S:C:T NODELIST(REASON)\n   17 PD 0:00     1 2       2     1       2:2:1 (Resources)\n   18 PD 0:00     1 2       2     1       2:2:1 (Resources)\n   19 PD 0:00     1 2       2     1       2:2:1 (Resources)\n   13  R 1:27     1 2       2     1       2:2:1 hydra12\n   14  R 1:26     1 2       2     1       2:2:1 hydra13\n   15  R 1:26     1 2       2     1       2:2:1 hydra14\n   16  R 1:26     1 2       2     1       2:2:1 hydra15\n\nThe squeue command can also display the memory size of jobs, for example:\n\n% sbatch --mem=123 tmp\nSubmitted batch job 24\n\n$ squeue -o \"%.5i %.2t %.4M %.5D %m\"\nJOBID ST TIME NODES MIN_MEMORY\n  24   R 0:05     1 123\n\nSee also 'squeue --help' and 'man squeue'\n\nscontrol\nThe following job settings can be adjusted using scontrol:\n\n\nRequested Allocation:\n  ReqSockets=<count>  Set the job's count of required sockets\n  ReqCores=<count>    Set the job's count of required cores\n  ReqThreads=<count>  Set the job's count of required threads\n\nFor example:\n\n# scontrol update JobID=17 ReqThreads=2\n# scontrol update JobID=18 ReqCores=4\n# scontrol update JobID=19 ReqSockets=8\n\n% squeue -o '%.5i %.2t %.4M %.5D %9c %7H %6I %8J'\nJOBID ST TIME NODES MIN_PROCS SOCKETS CORES THREADS\n   17 PD 0:00     1 1         4       2     1\n   18 PD 0:00     1 1         8       4     2\n   19 PD 0:00     1 1         4       2     1\n   13  R 1:35     1 0         0       0     0\n   14  R 1:34     1 0         0       0     0\n   15  R 1:34     1 0         0       0     0\n   16  R 1:34     1 0         0       0     0\n\nThe 'scontrol show job' command can be used to display\nthe number of allocated CPUs per node as well as the socket, cores,\nand threads specified in the request and constraints.\n\n\n% srun -N 2 -B 2:1 sleep 100 &\n% scontrol show job 20\nJobId=20 UserId=(30352) GroupId=users(1051)\n   Name=sleep\n   Priority=4294901749 Partition=parts BatchFlag=0\n   AllocNode:Sid=hydra16:3892 TimeLimit=UNLIMITED\n   JobState=RUNNING StartTime=09/25-17:17:30 EndTime=NONE\n   NodeList=hydra[12-14] NodeListIndices=0,2,-1\n   AllocCPUs=1,2,1\n   NumCPUs=4 ReqNodes=2 ReqS:C:T=2:1:*\n   OverSubscribe=0 Contiguous=0 CPUs/task=0\n   MinCPUs=0 MinMemory=0 MinTmpDisk=0 Features=(null)\n   Dependency=0 Account=(null) Reason=None Network=(null)\n   ReqNodeList=(null) ReqNodeListIndices=-1\n   ExcNodeList=(null) ExcNodeListIndices=-1\n   SubmitTime=09/25-17:17:30 SuspendTime=None PreSusTime=0\n\nSee also 'scontrol --help' and 'man scontrol'\n\nConfiguration settings in slurm.conf\n\n\nSeveral slurm.conf settings are available to control the multi-core\nfeatures described above.\n\nIn addition to the description below, also see the \"Task Launch\" and\n\"Resource Selection\" sections if generating slurm.conf\nvia configurator.html.\n\nAs previously mentioned, in order for the affinity to be set, the\ntask/affinity plugin must be first enabled in slurm.conf:\n\n\nTaskPlugin=task/affinity          # enable task affinity\n\nThis setting is part of the task launch specific parameters:\n\n# o Define task launch specific parameters\n#\n#    \"TaskProlog\" : Define a program to be executed as the user before each\n#                   task begins execution.\n#    \"TaskEpilog\" : Define a program to be executed as the user after each\n#                   task terminates.\n#    \"TaskPlugin\" : Define a task launch plugin. This may be used to\n#                   provide resource management within a node (e.g. pinning\n#                   tasks to specific processors). Permissible values are:\n#      \"task/affinity\" : CPU affinity support\n#      \"task/cgroup\"   : bind tasks to resources using Linux cgroup\n#      \"task/none\"     : no task launch actions, the default\n#\n# Example:\n#\n# TaskProlog=/usr/local/slurm/etc/task_prolog # default is none\n# TaskEpilog=/usr/local/slurm/etc/task_epilog # default is none\n# TaskPlugin=task/affinity                    # default is task/none\n\nDeclare the node hardware configuration in slurm.conf:\n\n\nNodeName=dualcore[01-16] CoresPerSocket=2 ThreadsPerCore=1\n\nFor a more complete description of the various node configuration options\nsee the slurm.conf man page.\n\nLast modified 19 May 2023\n"
        },
        {
            "title": "Configuration settings in slurm.conf\n\n",
            "content": "Several slurm.conf settings are available to control the multi-core\nfeatures described above.\n\nIn addition to the description below, also see the \"Task Launch\" and\n\"Resource Selection\" sections if generating slurm.conf\nvia configurator.html.\n\nAs previously mentioned, in order for the affinity to be set, the\ntask/affinity plugin must be first enabled in slurm.conf:\n\n\nTaskPlugin=task/affinity          # enable task affinity\n\nThis setting is part of the task launch specific parameters:\n\n# o Define task launch specific parameters\n#\n#    \"TaskProlog\" : Define a program to be executed as the user before each\n#                   task begins execution.\n#    \"TaskEpilog\" : Define a program to be executed as the user after each\n#                   task terminates.\n#    \"TaskPlugin\" : Define a task launch plugin. This may be used to\n#                   provide resource management within a node (e.g. pinning\n#                   tasks to specific processors). Permissible values are:\n#      \"task/affinity\" : CPU affinity support\n#      \"task/cgroup\"   : bind tasks to resources using Linux cgroup\n#      \"task/none\"     : no task launch actions, the default\n#\n# Example:\n#\n# TaskProlog=/usr/local/slurm/etc/task_prolog # default is none\n# TaskEpilog=/usr/local/slurm/etc/task_epilog # default is none\n# TaskPlugin=task/affinity                    # default is task/none\n\nDeclare the node hardware configuration in slurm.conf:\n\n\nNodeName=dualcore[01-16] CoresPerSocket=2 ThreadsPerCore=1\n\nFor a more complete description of the various node configuration options\nsee the slurm.conf man page.\n\nLast modified 19 May 2023\n"
        },
        {
            "title": "Low-level --cpu-bind=... - Explicit binding interface\n\n",
            "content": "The following srun flag provides a low-level core binding interface:\n--cpu-bind=        Bind tasks to CPUs\n    q[uiet]         quietly bind before task runs (default)\n    v[erbose]       verbosely report binding before task runs\n    no[ne]          don't bind tasks to CPUs (default)\n    rank            bind by task rank\n    map_cpu:<list>  specify a CPU ID binding for each task\n                    where <list> is\n                    <cpuid1>,<cpuid2>,...<cpuidN>\n    mask_cpu:<list> specify a CPU ID binding mask for each\n                    task where <list> is\n                    <mask1>,<mask2>,...<maskN>\n    rank_ldom       bind task by rank to CPUs in a NUMA\n                    locality domain\n    map_ldom:<list> specify a NUMA locality domain ID\n                    for each task where <list> is\n                    <ldom1>,<ldom2>,...<ldomN>\n    rank_ldom       bind task by rank to CPUs in a NUMA\n                    locality domain where <list> is\n                    <ldom1>,<ldom2>,...<ldomN>\n    mask_ldom:<list> specify a NUMA locality domain ID mask\n                    for each task where <list> is\n                    <ldom1>,<ldom2>,...<ldomN>\n    ldoms           auto-generated masks bind to NUMA locality\n                    domains\n    sockets         auto-generated masks bind to sockets\n    cores           auto-generated masks bind to cores\n    threads         auto-generated masks bind to threads\n    help            show this help message\n The affinity can be either set to either a specific logical processor\n(socket, core, threads) or at a coarser granularity than the lowest level\nof logical processor (core or thread).\nIn the later case the processes are allowed to utilize multiple processors\nwithin a specific socket or core.\n\nExamples:\n\n\n srun -n 8 -N 4 --cpu-bind=mask_cpu:0x1,0x4 a.out\n srun -n 8 -N 4 --cpu-bind=mask_cpu:0x3,0xD a.out\n\n\nSee also 'srun --cpu-bind=help' and 'man srun'\n\nHigh-level -B S[:C[:T]] - Automatic mask generation interface\n\n\nWe have updated the node\nselection infrastructure with a mechanism that allows selection of logical\nprocessors at a finer granularity. Users are able to request a specific number\nof nodes, sockets,\u00a0 cores, and threads:\n\n-B, --extra-node-info=S[:C[:T]]            Expands to:\n  --sockets-per-node=S   number of sockets per node to allocate\n  --cores-per-socket=C   number of cores per socket to allocate\n  --threads-per-core=T   number of threads per core to allocate\n                each field can be 'min' or wildcard '*'\n\n     Total cpus requested = (Nodes) x (S x C x T)\n\nExamples:\n\n\n\n srun -n 8 -N 4 -B 2:1 a.out\n srun -n 8 -N 4 -B 2   a.out\n\nnote: compare the above with the previous corresponding --cpu-bind=... examples\n\n srun -n 16 -N 4 a.out\n srun -n 16 -N 4 -B 2:2:1 a.out\n srun -n 16 -N 4 -B 2:2:1 a.out\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0or\n srun -n 16 -N 4 --sockets-per-node=2 --cores-per-socket=2 --threads-per-core=1 a.out\n srun -n 16 -N 2-4 -B '1:*:1' a.out\n srun -n 16 -N 4-2 -B '2:*:1' a.out\n srun -n 16 -N 4-4 -B '1:1' a.out\n\n\nNotes:\n\n Adding --cpu-bind=no to the command line will cause the processes\n      to not be bound the logical processors.\n  Adding --cpu-bind=verbose to the command line (or setting the\n      CPU_BIND environment variable to \"verbose\") will cause each task\n      to report the affinity mask in use\n  Binding is on by default when -B is used. The default binding on\n      multi-core/multi-threaded systems is equivalent to the level of\n      resource enumerated in the -B option.\n\nSee also 'srun --help' and 'man srun'\nTask distribution options: Extensions to -m / --distribution\n\n\nThe -m / --distribution option for distributing processes across nodes\nhas been extended to also describe the distribution within the lowest level\nof logical processors.\nAvailable distributions include:\n\narbitrary | block | cyclic | plane=x | [block|cyclic]:[block|cyclic|fcyclic]\n\nThe  plane distribution (plane=x)\nresults in a block:cyclic distribution of blocksize equal to x.\nIn the following we use \"lowest level of logical processors\"\nto describe sockets, cores or threads depending of the architecture.\nThe distribution divides\nthe cluster into planes (including a number of the lowest level of logical\nprocessors on each node) and then schedule first within each plane and then\nacross planes.\nFor the two dimensional distributions ([block|cyclic]:[block|cyclic|fcyclic]),\nthe second distribution (after \":\") allows users to specify a distribution\nmethod for processes within a node and applies to the lowest level of logical\nprocessors (sockets, core or thread depending on the architecture).\nWhen a task requires more than one CPU, the cyclic will allocate all\nof those CPUs as a group (i.e. within the same socket if possible) while \nfcyclic would distribute each of those CPU of the in a cyclic fashion\nacross sockets.\nThe binding is enabled automatically when high level flags are used as long\nas the task/affinity plug-in is enabled. To disable binding at the job level\nuse --cpu-bind=no.\nThe distribution flags can be combined with the other switches:\n\n\n\nsrun -n 16 -N 4 -B '2:*:1' -m block:cyclic --cpu-bind=socket a.out\nsrun -n 16 -N 4 -B '2:*:1' -m plane=2 --cpu-bind=core a.out\nsrun -n 16 -N 4 -B '2:*:1' -m plane=2 a.out\n\n\nThe default distribution on multi-core/multi-threaded systems is equivalent\nto -m block:cyclic with --cpu-bind=thread.\nSee also 'srun --help'\nMemory as a Consumable Resource\n\n\nThe --mem flag specifies the maximum amount of memory in MB\nneeded by the job per node.  This flag is used to support the memory\nas a consumable resource allocation strategy.\n\n--mem=MB      maximum amount of real memory per node\n              required by the job.\n\nThis flag allows the scheduler to co-allocate jobs on specific nodes\ngiven that their added memory requirement do not exceed the total amount\nof memory on the nodes.\nIn order to use memory as a consumable resource, the select/cons_tres\nplugin must be first enabled in slurm.conf:\n\nSelectType=select/cons_tres     # enable consumable resources\nSelectTypeParameters=CR_Memory  # memory as a consumable resource\n\n Using memory as a consumable resource is typically combined with\nthe CPU, Socket, or Core consumable resources using SelectTypeParameters\nvalues of: CR_CPU_Memory, CR_Socket_Memory or CR_Core_Memory\n\nSee the \"Resource Selection\" section if generating slurm.conf\nvia configurator.html.\n\nSee also 'srun --help' and 'man srun'\nTask invocation as a function of logical processors\n\n\nThe --ntasks-per-{node,socket,core}=ntasks flags\nallow the user to request that no more than ntasks\nbe invoked on each node, socket, or core.\nThis is similar to using --cpus-per-task=ncpus\nbut does not require knowledge of the actual number of cpus on\neach node.  In some cases, it is more convenient to be able to\nrequest that no more than a specific number of ntasks be invoked\non each node, socket, or core.  Examples of this include submitting\nan app where only one \"task/rank\" should be\nassigned to each node while allowing the job to utilize\nall of the parallelism present in the node, or submitting a single\nsetup/cleanup/monitoring job to each node of a pre-existing\nallocation as one step in a larger job script.\nThis can now be specified via the following flags:\n\n--ntasks-per-node=n    number of tasks to invoke on each node\n--ntasks-per-socket=n  number of tasks to invoke on each socket\n--ntasks-per-core=n    number of tasks to invoke on each core\n\nFor example, given a cluster with nodes containing two sockets,\neach containing two cores, the following commands illustrate the\nbehavior of these flags:\n\n% srun -n 4 hostname\nhydra12\nhydra12\nhydra12\nhydra12\n% srun -n 4 --ntasks-per-node=1 hostname\nhydra12\nhydra13\nhydra14\nhydra15\n% srun -n 4 --ntasks-per-node=2 hostname\nhydra12\nhydra12\nhydra13\nhydra13\n% srun -n 4 --ntasks-per-socket=1 hostname\nhydra12\nhydra12\nhydra13\nhydra13\n% srun -n 4 --ntasks-per-core=1 hostname\nhydra12\nhydra12\nhydra12\nhydra12\n\nSee also 'srun --help' and 'man srun'\nApplication hints\n\n\nDifferent applications will have various levels of resource\nrequirements. Some applications tend to be computationally intensive\nbut require little to no inter-process communication. Some applications\nwill be memory bound, saturating the memory bandwidth of a processor\nbefore exhausting the computational capabilities. Other applications\nwill be highly communication intensive causing processes to block\nawaiting messages from other processes. Applications with these\ndifferent properties tend to run well on a multi-core system given\nthe right mappings.\nFor computationally intensive applications, all cores in a multi-core\nsystem would normally be used. For memory bound applications, only\nusing a single core on each socket will result in the highest per\ncore memory bandwidth. For communication intensive applications,\nusing in-core multi-threading (e.g. hyperthreading, SMT, or TMT)\nmay also improve performance.\nThe following command line flags can be used to communicate these\ntypes of application hints to the Slurm multi-core support:\n\n--hint=             Bind tasks according to application hints\n    compute_bound   use all cores in each socket\n    memory_bound    use only one core in each socket\n    [no]multithread [don't] use extra threads with in-core multi-threading\n    help            show this help message\n\nFor example, given a cluster with nodes containing two sockets,\neach containing two cores, the following commands illustrate the\nbehavior of these flags.  In the verbose --cpu-bind output, tasks\nare described as 'hostname, task Global_ID Local_ID [PID]':\n\n% srun -n 4 --hint=compute_bound --cpu-bind=verbose sleep 1\ncpu-bind=MASK - hydra12, task  0  0 [15425]: mask 0x1 set\ncpu-bind=MASK - hydra12, task  1  1 [15426]: mask 0x4 set\ncpu-bind=MASK - hydra12, task  2  2 [15427]: mask 0x2 set\ncpu-bind=MASK - hydra12, task  3  3 [15428]: mask 0x8 set\n\n% srun -n 4 --hint=memory_bound --cpu-bind=verbose sleep 1\ncpu-bind=MASK - hydra12, task  0  0 [15550]: mask 0x1 set\ncpu-bind=MASK - hydra12, task  1  1 [15551]: mask 0x4 set\ncpu-bind=MASK - hydra13, task  2  0 [14974]: mask 0x1 set\ncpu-bind=MASK - hydra13, task  3  1 [14975]: mask 0x4 set\n\nSee also 'srun --hint=help' and 'man srun'\n\nMotivation behind high-level srun flags\n\n\nThe motivation behind allowing users to use higher level srun\nflags instead of --cpu-bind is that the later can be difficult to use. The\nproposed high-level flags are easier to use than --cpu-bind because:\n\nAffinity mask generation happens automatically when using the high-level flags. \nThe length and complexity of the --cpu-bind flag vs. the length\nof the combination of -B and --distribution flags make the high-level\nflags much easier to use.\n\nAlso as illustrated in the example below it is much simpler to specify\na different layout using the high-level flags since users do not have to\nrecalculate mask or CPU IDs. This approach is much simpler than\nrearranging the mask or map.\nGiven a 32-process job and a four node, dual-socket, dual-core\ncluster, we want to use a block distribution across the four nodes and then a\ncyclic distribution within the node across the physical processors. Below we\nshow how to obtain the wanted layout using 1) high-level flags and\n2) --cpubind\nHigh-Level flags\n\n\nUsing Slurm's high-level flag, users can obtain the above layout with\neither of the following submissions since --distribution=block:cyclic\nis the default distribution method.\n\n$ srun -n 32 -N 4 -B 4:2 --distribution=block:cyclic a.out\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0or\n\n$ srun -n 32 -N 4 -B 4:2 a.out\n\nThe cores are shown as c0 and c1 and the processors are shown\nas p0 through p3. The resulting task IDs are: \n\n\n\n\n \nc0c1\np0 0  4 \np2 2  6 \n\n\n\n\n\n\n \nc0c1\np1 1  5 \np3 3  7 \n\n\n\n\nThe computation and assignment of the task IDs is transparent\nto the user. Users don't have to worry about the core numbering (Section\nPinning processes to cores) or any setting any CPU affinities. By default CPU affinity\nwill be set when using multi-core supporting flags. \nLow-level flag --cpu-bind\n\n\nUsing Slurm's --cpu-bind flag, users must compute the CPU IDs or\nmasks as well as make sure they understand the core numbering on their\nsystem. Another problem arises when core numbering is not the same on all\nnodes. The --cpu-bind option only allows users to specify a single\nmask for all the nodes. Using Slurm high-level flags remove this limitation\nsince Slurm will correctly generate the appropriate masks for each requested nodes.\n\nOn a four dual-socket dual-core node cluster with core block numbering\n\n\nThe cores are shown as c0 and c1 and the processors are shown\nas p0 through p3. The CPU IDs within a node in the block numbering are:\n(this information is available from the /proc/cpuinfo file on the system)\n\n\n\n\n \nc0c1\np0 0  1 \np2 4  5 \n\n\n\n\n\n\n \nc0c1\np1 2  3 \np3 6  7 \n\n\n\n\n\u00a0resulting in the following mapping for processor/cores\nand task IDs which users need to calculate: \n\nmapping for processors/cores\n\n\n\n\n\n \nc0c1\np0 0x01  0x02 \np2 0x10  0x20 \n\n\n\n\n\n\n \nc0c1\np1 0x04  0x08 \np3 0x40  0x80 \n\n\n\n\n\n\ntask IDs\n\n\n\n\n\n \nc0c1\np0 0  4 \np2 2  6 \n\n\n\n\n\n\n \nc0c1\np1 1  5 \np3 3  7 \n\n\n\n\nThe above maps and task IDs can be translated into the\nfollowing command:\n\n$ srun -n 32 -N 4 --cpu-bind=mask_cpu:1,4,10,40,2,8,20,80 a.out\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0or\n\n$ srun -n 32 -N 4 --cpu-bind=map_cpu:0,2,4,6,1,3,5,7 a.out\n\n\nSame cluster but with its core numbered cyclic instead of block\n\n\nOn a system with cyclically numbered cores, the correct mask\nargument to the srun command looks like: (this will\nachieve the same layout as the command above on a system with core block\nnumbering.)\n\n$ srun -n 32 -N 4 --cpu-bind=map_cpu:0,1,2,3,4,5,6,7 a.out\n\nBlock map_cpu on a system with cyclic core numbering\n\n\nIf users do not check their system's core numbering before specifying\nthe map_cpu list and thereby do not realize that the system has cyclic core\nnumbering instead of block numbering then they will not get the expected\nlayout. For example, if they decide to re-use their command from above:\n\n$ srun -n 32 -N 4 --cpu-bind=map_cpu:0,2,4,6,1,3,5,7 a.out\n\nthey get the following unintentional task ID layout:\n\n\n\n\n \nc0c1\np0 0  2 \np2 1  3 \n\n\n\n\n\n\n \nc0c1\np1 4  6 \np3 5  7 \n\n\n\n\nsince the processor IDs within a node in the cyclic numbering are:\n\n\n\n\n \nc0c1\np0 0  4 \np2 2  6 \n\n\n\n\n\n\n \nc0c1\np1 1  5 \np3 3  7 \n\n\n\n\nThe important conclusion is that using the --cpu-bind flag is not\ntrivial and that it assumes that users are experts.\n\nExtensions to sinfo/squeue/scontrol\n\n\nSeveral extensions have also been made to the other Slurm utilities to\nmake working with multi-core/multi-threaded systems easier.\n\nsinfo\nThe long version (-l) of the sinfo node listing (-N) has been\nextended to display the sockets, cores, and threads present for each\nnode.  For example:\n\n\n% sinfo -N\nNODELIST     NODES PARTITION STATE\nhydra[12-15]     4    parts* idle\n\n% sinfo -lN\nThu Sep 14 17:47:13 2006\nNODELIST     NODES PARTITION       STATE CPUS    S:C:T MEMORY TMP_DISK WEIGHT FEATURES REASON\nhydra[12-15]     4    parts*        idle   8+ 2+:4+:1+   2007    41447      1   (null) none\n\n% sinfo -lNe\nThu Sep 14 17:47:18 2006\nNODELIST     NODES PARTITION       STATE CPUS    S:C:T MEMORY TMP_DISK WEIGHT FEATURES REASON\n\nhydra[12-14]     3    parts*        idle    8    2:4:1   2007    41447      1   (null) none\nhydra15          1    parts*        idle   64    8:4:2   2007    41447      1   (null) none\n\nFor user specified output formats (-o/--format) and sorting (-S/--sort),\nthe following identifiers are available:\n\n%X  Number of sockets per node\n%Y  Number of cores per socket\n%Z  Number of threads per core\n%z  Extended processor information: number of\n    sockets, core, threads (S:C:T) per node\n\nFor example:\n\n% sinfo -o '%9P %4c %8z %8X %8Y %8Z'\nPARTITION CPUS S:C:T    SOCKETS  CORES    THREADS\nparts*    4    2:2:1    2        2        1\n\nSee also 'sinfo --help' and 'man sinfo'\n\nsqueue\nFor user specified output formats (-o/--format) and sorting (-S/--sort),\nthe following identifiers are available:\n\n%m  Size of memory (in MB) requested by the job\n%H  Number of requested sockets per node\n%I  Number of requested cores per socket\n%J  Number of requested threads per core\n%z  Extended processor information: number of requested\n    sockets, cores, threads (S:C:T) per node\n\nBelow is an example squeue output after running 7 copies of:\n\n\n% srun -n 4 -B 2:2:1 --mem=1024 sleep 100 &\n\n\n\n% squeue -o '%.5i %.2t %.4M %.5D %7H %6I %7J %6z %R'\nJOBID ST TIME NODES SOCKETS CORES THREADS S:C:T NODELIST(REASON)\n   17 PD 0:00     1 2       2     1       2:2:1 (Resources)\n   18 PD 0:00     1 2       2     1       2:2:1 (Resources)\n   19 PD 0:00     1 2       2     1       2:2:1 (Resources)\n   13  R 1:27     1 2       2     1       2:2:1 hydra12\n   14  R 1:26     1 2       2     1       2:2:1 hydra13\n   15  R 1:26     1 2       2     1       2:2:1 hydra14\n   16  R 1:26     1 2       2     1       2:2:1 hydra15\n\nThe squeue command can also display the memory size of jobs, for example:\n\n% sbatch --mem=123 tmp\nSubmitted batch job 24\n\n$ squeue -o \"%.5i %.2t %.4M %.5D %m\"\nJOBID ST TIME NODES MIN_MEMORY\n  24   R 0:05     1 123\n\nSee also 'squeue --help' and 'man squeue'\n\nscontrol\nThe following job settings can be adjusted using scontrol:\n\n\nRequested Allocation:\n  ReqSockets=<count>  Set the job's count of required sockets\n  ReqCores=<count>    Set the job's count of required cores\n  ReqThreads=<count>  Set the job's count of required threads\n\nFor example:\n\n# scontrol update JobID=17 ReqThreads=2\n# scontrol update JobID=18 ReqCores=4\n# scontrol update JobID=19 ReqSockets=8\n\n% squeue -o '%.5i %.2t %.4M %.5D %9c %7H %6I %8J'\nJOBID ST TIME NODES MIN_PROCS SOCKETS CORES THREADS\n   17 PD 0:00     1 1         4       2     1\n   18 PD 0:00     1 1         8       4     2\n   19 PD 0:00     1 1         4       2     1\n   13  R 1:35     1 0         0       0     0\n   14  R 1:34     1 0         0       0     0\n   15  R 1:34     1 0         0       0     0\n   16  R 1:34     1 0         0       0     0\n\nThe 'scontrol show job' command can be used to display\nthe number of allocated CPUs per node as well as the socket, cores,\nand threads specified in the request and constraints.\n\n\n% srun -N 2 -B 2:1 sleep 100 &\n% scontrol show job 20\nJobId=20 UserId=(30352) GroupId=users(1051)\n   Name=sleep\n   Priority=4294901749 Partition=parts BatchFlag=0\n   AllocNode:Sid=hydra16:3892 TimeLimit=UNLIMITED\n   JobState=RUNNING StartTime=09/25-17:17:30 EndTime=NONE\n   NodeList=hydra[12-14] NodeListIndices=0,2,-1\n   AllocCPUs=1,2,1\n   NumCPUs=4 ReqNodes=2 ReqS:C:T=2:1:*\n   OverSubscribe=0 Contiguous=0 CPUs/task=0\n   MinCPUs=0 MinMemory=0 MinTmpDisk=0 Features=(null)\n   Dependency=0 Account=(null) Reason=None Network=(null)\n   ReqNodeList=(null) ReqNodeListIndices=-1\n   ExcNodeList=(null) ExcNodeListIndices=-1\n   SubmitTime=09/25-17:17:30 SuspendTime=None PreSusTime=0\n\nSee also 'scontrol --help' and 'man scontrol'\n\nConfiguration settings in slurm.conf\n\n\nSeveral slurm.conf settings are available to control the multi-core\nfeatures described above.\n\nIn addition to the description below, also see the \"Task Launch\" and\n\"Resource Selection\" sections if generating slurm.conf\nvia configurator.html.\n\nAs previously mentioned, in order for the affinity to be set, the\ntask/affinity plugin must be first enabled in slurm.conf:\n\n\nTaskPlugin=task/affinity          # enable task affinity\n\nThis setting is part of the task launch specific parameters:\n\n# o Define task launch specific parameters\n#\n#    \"TaskProlog\" : Define a program to be executed as the user before each\n#                   task begins execution.\n#    \"TaskEpilog\" : Define a program to be executed as the user after each\n#                   task terminates.\n#    \"TaskPlugin\" : Define a task launch plugin. This may be used to\n#                   provide resource management within a node (e.g. pinning\n#                   tasks to specific processors). Permissible values are:\n#      \"task/affinity\" : CPU affinity support\n#      \"task/cgroup\"   : bind tasks to resources using Linux cgroup\n#      \"task/none\"     : no task launch actions, the default\n#\n# Example:\n#\n# TaskProlog=/usr/local/slurm/etc/task_prolog # default is none\n# TaskEpilog=/usr/local/slurm/etc/task_epilog # default is none\n# TaskPlugin=task/affinity                    # default is task/none\n\nDeclare the node hardware configuration in slurm.conf:\n\n\nNodeName=dualcore[01-16] CoresPerSocket=2 ThreadsPerCore=1\n\nFor a more complete description of the various node configuration options\nsee the slurm.conf man page.\n\nLast modified 19 May 2023\n"
        },
        {
            "title": "\nHigh-level -B S[:C[:T]] - Automatic mask generation interface\n\n",
            "content": "We have updated the node\nselection infrastructure with a mechanism that allows selection of logical\nprocessors at a finer granularity. Users are able to request a specific number\nof nodes, sockets,\u00a0 cores, and threads:\n-B, --extra-node-info=S[:C[:T]]            Expands to:\n  --sockets-per-node=S   number of sockets per node to allocate\n  --cores-per-socket=C   number of cores per socket to allocate\n  --threads-per-core=T   number of threads per core to allocate\n                each field can be 'min' or wildcard '*'\n\n     Total cpus requested = (Nodes) x (S x C x T)\nExamples:\n\n\n\n srun -n 8 -N 4 -B 2:1 a.out\n srun -n 8 -N 4 -B 2   a.out\n\nnote: compare the above with the previous corresponding --cpu-bind=... examples\n\n srun -n 16 -N 4 a.out\n srun -n 16 -N 4 -B 2:2:1 a.out\n srun -n 16 -N 4 -B 2:2:1 a.out\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0or\n srun -n 16 -N 4 --sockets-per-node=2 --cores-per-socket=2 --threads-per-core=1 a.out\n srun -n 16 -N 2-4 -B '1:*:1' a.out\n srun -n 16 -N 4-2 -B '2:*:1' a.out\n srun -n 16 -N 4-4 -B '1:1' a.out\n\n\nNotes:\n\n Adding --cpu-bind=no to the command line will cause the processes\n      to not be bound the logical processors.\n  Adding --cpu-bind=verbose to the command line (or setting the\n      CPU_BIND environment variable to \"verbose\") will cause each task\n      to report the affinity mask in use\n  Binding is on by default when -B is used. The default binding on\n      multi-core/multi-threaded systems is equivalent to the level of\n      resource enumerated in the -B option.\n\nSee also 'srun --help' and 'man srun'\nTask distribution options: Extensions to -m / --distribution\n\n\nThe -m / --distribution option for distributing processes across nodes\nhas been extended to also describe the distribution within the lowest level\nof logical processors.\nAvailable distributions include:\n\narbitrary | block | cyclic | plane=x | [block|cyclic]:[block|cyclic|fcyclic]\n\nThe  plane distribution (plane=x)\nresults in a block:cyclic distribution of blocksize equal to x.\nIn the following we use \"lowest level of logical processors\"\nto describe sockets, cores or threads depending of the architecture.\nThe distribution divides\nthe cluster into planes (including a number of the lowest level of logical\nprocessors on each node) and then schedule first within each plane and then\nacross planes.\nFor the two dimensional distributions ([block|cyclic]:[block|cyclic|fcyclic]),\nthe second distribution (after \":\") allows users to specify a distribution\nmethod for processes within a node and applies to the lowest level of logical\nprocessors (sockets, core or thread depending on the architecture).\nWhen a task requires more than one CPU, the cyclic will allocate all\nof those CPUs as a group (i.e. within the same socket if possible) while \nfcyclic would distribute each of those CPU of the in a cyclic fashion\nacross sockets.\nThe binding is enabled automatically when high level flags are used as long\nas the task/affinity plug-in is enabled. To disable binding at the job level\nuse --cpu-bind=no.\nThe distribution flags can be combined with the other switches:\n\n\n\nsrun -n 16 -N 4 -B '2:*:1' -m block:cyclic --cpu-bind=socket a.out\nsrun -n 16 -N 4 -B '2:*:1' -m plane=2 --cpu-bind=core a.out\nsrun -n 16 -N 4 -B '2:*:1' -m plane=2 a.out\n\n\nThe default distribution on multi-core/multi-threaded systems is equivalent\nto -m block:cyclic with --cpu-bind=thread.\nSee also 'srun --help'\nMemory as a Consumable Resource\n\n\nThe --mem flag specifies the maximum amount of memory in MB\nneeded by the job per node.  This flag is used to support the memory\nas a consumable resource allocation strategy.\n\n--mem=MB      maximum amount of real memory per node\n              required by the job.\n\nThis flag allows the scheduler to co-allocate jobs on specific nodes\ngiven that their added memory requirement do not exceed the total amount\nof memory on the nodes.\nIn order to use memory as a consumable resource, the select/cons_tres\nplugin must be first enabled in slurm.conf:\n\nSelectType=select/cons_tres     # enable consumable resources\nSelectTypeParameters=CR_Memory  # memory as a consumable resource\n\n Using memory as a consumable resource is typically combined with\nthe CPU, Socket, or Core consumable resources using SelectTypeParameters\nvalues of: CR_CPU_Memory, CR_Socket_Memory or CR_Core_Memory\n\nSee the \"Resource Selection\" section if generating slurm.conf\nvia configurator.html.\n\nSee also 'srun --help' and 'man srun'\nTask invocation as a function of logical processors\n\n\nThe --ntasks-per-{node,socket,core}=ntasks flags\nallow the user to request that no more than ntasks\nbe invoked on each node, socket, or core.\nThis is similar to using --cpus-per-task=ncpus\nbut does not require knowledge of the actual number of cpus on\neach node.  In some cases, it is more convenient to be able to\nrequest that no more than a specific number of ntasks be invoked\non each node, socket, or core.  Examples of this include submitting\nan app where only one \"task/rank\" should be\nassigned to each node while allowing the job to utilize\nall of the parallelism present in the node, or submitting a single\nsetup/cleanup/monitoring job to each node of a pre-existing\nallocation as one step in a larger job script.\nThis can now be specified via the following flags:\n\n--ntasks-per-node=n    number of tasks to invoke on each node\n--ntasks-per-socket=n  number of tasks to invoke on each socket\n--ntasks-per-core=n    number of tasks to invoke on each core\n\nFor example, given a cluster with nodes containing two sockets,\neach containing two cores, the following commands illustrate the\nbehavior of these flags:\n\n% srun -n 4 hostname\nhydra12\nhydra12\nhydra12\nhydra12\n% srun -n 4 --ntasks-per-node=1 hostname\nhydra12\nhydra13\nhydra14\nhydra15\n% srun -n 4 --ntasks-per-node=2 hostname\nhydra12\nhydra12\nhydra13\nhydra13\n% srun -n 4 --ntasks-per-socket=1 hostname\nhydra12\nhydra12\nhydra13\nhydra13\n% srun -n 4 --ntasks-per-core=1 hostname\nhydra12\nhydra12\nhydra12\nhydra12\n\nSee also 'srun --help' and 'man srun'\nApplication hints\n\n\nDifferent applications will have various levels of resource\nrequirements. Some applications tend to be computationally intensive\nbut require little to no inter-process communication. Some applications\nwill be memory bound, saturating the memory bandwidth of a processor\nbefore exhausting the computational capabilities. Other applications\nwill be highly communication intensive causing processes to block\nawaiting messages from other processes. Applications with these\ndifferent properties tend to run well on a multi-core system given\nthe right mappings.\nFor computationally intensive applications, all cores in a multi-core\nsystem would normally be used. For memory bound applications, only\nusing a single core on each socket will result in the highest per\ncore memory bandwidth. For communication intensive applications,\nusing in-core multi-threading (e.g. hyperthreading, SMT, or TMT)\nmay also improve performance.\nThe following command line flags can be used to communicate these\ntypes of application hints to the Slurm multi-core support:\n\n--hint=             Bind tasks according to application hints\n    compute_bound   use all cores in each socket\n    memory_bound    use only one core in each socket\n    [no]multithread [don't] use extra threads with in-core multi-threading\n    help            show this help message\n\nFor example, given a cluster with nodes containing two sockets,\neach containing two cores, the following commands illustrate the\nbehavior of these flags.  In the verbose --cpu-bind output, tasks\nare described as 'hostname, task Global_ID Local_ID [PID]':\n\n% srun -n 4 --hint=compute_bound --cpu-bind=verbose sleep 1\ncpu-bind=MASK - hydra12, task  0  0 [15425]: mask 0x1 set\ncpu-bind=MASK - hydra12, task  1  1 [15426]: mask 0x4 set\ncpu-bind=MASK - hydra12, task  2  2 [15427]: mask 0x2 set\ncpu-bind=MASK - hydra12, task  3  3 [15428]: mask 0x8 set\n\n% srun -n 4 --hint=memory_bound --cpu-bind=verbose sleep 1\ncpu-bind=MASK - hydra12, task  0  0 [15550]: mask 0x1 set\ncpu-bind=MASK - hydra12, task  1  1 [15551]: mask 0x4 set\ncpu-bind=MASK - hydra13, task  2  0 [14974]: mask 0x1 set\ncpu-bind=MASK - hydra13, task  3  1 [14975]: mask 0x4 set\n\nSee also 'srun --hint=help' and 'man srun'\n\nMotivation behind high-level srun flags\n\n\nThe motivation behind allowing users to use higher level srun\nflags instead of --cpu-bind is that the later can be difficult to use. The\nproposed high-level flags are easier to use than --cpu-bind because:\n\nAffinity mask generation happens automatically when using the high-level flags. \nThe length and complexity of the --cpu-bind flag vs. the length\nof the combination of -B and --distribution flags make the high-level\nflags much easier to use.\n\nAlso as illustrated in the example below it is much simpler to specify\na different layout using the high-level flags since users do not have to\nrecalculate mask or CPU IDs. This approach is much simpler than\nrearranging the mask or map.\nGiven a 32-process job and a four node, dual-socket, dual-core\ncluster, we want to use a block distribution across the four nodes and then a\ncyclic distribution within the node across the physical processors. Below we\nshow how to obtain the wanted layout using 1) high-level flags and\n2) --cpubind\nHigh-Level flags\n\n\nUsing Slurm's high-level flag, users can obtain the above layout with\neither of the following submissions since --distribution=block:cyclic\nis the default distribution method.\n\n$ srun -n 32 -N 4 -B 4:2 --distribution=block:cyclic a.out\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0or\n\n$ srun -n 32 -N 4 -B 4:2 a.out\n\nThe cores are shown as c0 and c1 and the processors are shown\nas p0 through p3. The resulting task IDs are: \n\n\n\n\n \nc0c1\np0 0  4 \np2 2  6 \n\n\n\n\n\n\n \nc0c1\np1 1  5 \np3 3  7 \n\n\n\n\nThe computation and assignment of the task IDs is transparent\nto the user. Users don't have to worry about the core numbering (Section\nPinning processes to cores) or any setting any CPU affinities. By default CPU affinity\nwill be set when using multi-core supporting flags. \nLow-level flag --cpu-bind\n\n\nUsing Slurm's --cpu-bind flag, users must compute the CPU IDs or\nmasks as well as make sure they understand the core numbering on their\nsystem. Another problem arises when core numbering is not the same on all\nnodes. The --cpu-bind option only allows users to specify a single\nmask for all the nodes. Using Slurm high-level flags remove this limitation\nsince Slurm will correctly generate the appropriate masks for each requested nodes.\n\nOn a four dual-socket dual-core node cluster with core block numbering\n\n\nThe cores are shown as c0 and c1 and the processors are shown\nas p0 through p3. The CPU IDs within a node in the block numbering are:\n(this information is available from the /proc/cpuinfo file on the system)\n\n\n\n\n \nc0c1\np0 0  1 \np2 4  5 \n\n\n\n\n\n\n \nc0c1\np1 2  3 \np3 6  7 \n\n\n\n\n\u00a0resulting in the following mapping for processor/cores\nand task IDs which users need to calculate: \n\nmapping for processors/cores\n\n\n\n\n\n \nc0c1\np0 0x01  0x02 \np2 0x10  0x20 \n\n\n\n\n\n\n \nc0c1\np1 0x04  0x08 \np3 0x40  0x80 \n\n\n\n\n\n\ntask IDs\n\n\n\n\n\n \nc0c1\np0 0  4 \np2 2  6 \n\n\n\n\n\n\n \nc0c1\np1 1  5 \np3 3  7 \n\n\n\n\nThe above maps and task IDs can be translated into the\nfollowing command:\n\n$ srun -n 32 -N 4 --cpu-bind=mask_cpu:1,4,10,40,2,8,20,80 a.out\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0or\n\n$ srun -n 32 -N 4 --cpu-bind=map_cpu:0,2,4,6,1,3,5,7 a.out\n\n\nSame cluster but with its core numbered cyclic instead of block\n\n\nOn a system with cyclically numbered cores, the correct mask\nargument to the srun command looks like: (this will\nachieve the same layout as the command above on a system with core block\nnumbering.)\n\n$ srun -n 32 -N 4 --cpu-bind=map_cpu:0,1,2,3,4,5,6,7 a.out\n\nBlock map_cpu on a system with cyclic core numbering\n\n\nIf users do not check their system's core numbering before specifying\nthe map_cpu list and thereby do not realize that the system has cyclic core\nnumbering instead of block numbering then they will not get the expected\nlayout. For example, if they decide to re-use their command from above:\n\n$ srun -n 32 -N 4 --cpu-bind=map_cpu:0,2,4,6,1,3,5,7 a.out\n\nthey get the following unintentional task ID layout:\n\n\n\n\n \nc0c1\np0 0  2 \np2 1  3 \n\n\n\n\n\n\n \nc0c1\np1 4  6 \np3 5  7 \n\n\n\n\nsince the processor IDs within a node in the cyclic numbering are:\n\n\n\n\n \nc0c1\np0 0  4 \np2 2  6 \n\n\n\n\n\n\n \nc0c1\np1 1  5 \np3 3  7 \n\n\n\n\nThe important conclusion is that using the --cpu-bind flag is not\ntrivial and that it assumes that users are experts.\n\nExtensions to sinfo/squeue/scontrol\n\n\nSeveral extensions have also been made to the other Slurm utilities to\nmake working with multi-core/multi-threaded systems easier.\n\nsinfo\nThe long version (-l) of the sinfo node listing (-N) has been\nextended to display the sockets, cores, and threads present for each\nnode.  For example:\n\n\n% sinfo -N\nNODELIST     NODES PARTITION STATE\nhydra[12-15]     4    parts* idle\n\n% sinfo -lN\nThu Sep 14 17:47:13 2006\nNODELIST     NODES PARTITION       STATE CPUS    S:C:T MEMORY TMP_DISK WEIGHT FEATURES REASON\nhydra[12-15]     4    parts*        idle   8+ 2+:4+:1+   2007    41447      1   (null) none\n\n% sinfo -lNe\nThu Sep 14 17:47:18 2006\nNODELIST     NODES PARTITION       STATE CPUS    S:C:T MEMORY TMP_DISK WEIGHT FEATURES REASON\n\nhydra[12-14]     3    parts*        idle    8    2:4:1   2007    41447      1   (null) none\nhydra15          1    parts*        idle   64    8:4:2   2007    41447      1   (null) none\n\nFor user specified output formats (-o/--format) and sorting (-S/--sort),\nthe following identifiers are available:\n\n%X  Number of sockets per node\n%Y  Number of cores per socket\n%Z  Number of threads per core\n%z  Extended processor information: number of\n    sockets, core, threads (S:C:T) per node\n\nFor example:\n\n% sinfo -o '%9P %4c %8z %8X %8Y %8Z'\nPARTITION CPUS S:C:T    SOCKETS  CORES    THREADS\nparts*    4    2:2:1    2        2        1\n\nSee also 'sinfo --help' and 'man sinfo'\n\nsqueue\nFor user specified output formats (-o/--format) and sorting (-S/--sort),\nthe following identifiers are available:\n\n%m  Size of memory (in MB) requested by the job\n%H  Number of requested sockets per node\n%I  Number of requested cores per socket\n%J  Number of requested threads per core\n%z  Extended processor information: number of requested\n    sockets, cores, threads (S:C:T) per node\n\nBelow is an example squeue output after running 7 copies of:\n\n\n% srun -n 4 -B 2:2:1 --mem=1024 sleep 100 &\n\n\n\n% squeue -o '%.5i %.2t %.4M %.5D %7H %6I %7J %6z %R'\nJOBID ST TIME NODES SOCKETS CORES THREADS S:C:T NODELIST(REASON)\n   17 PD 0:00     1 2       2     1       2:2:1 (Resources)\n   18 PD 0:00     1 2       2     1       2:2:1 (Resources)\n   19 PD 0:00     1 2       2     1       2:2:1 (Resources)\n   13  R 1:27     1 2       2     1       2:2:1 hydra12\n   14  R 1:26     1 2       2     1       2:2:1 hydra13\n   15  R 1:26     1 2       2     1       2:2:1 hydra14\n   16  R 1:26     1 2       2     1       2:2:1 hydra15\n\nThe squeue command can also display the memory size of jobs, for example:\n\n% sbatch --mem=123 tmp\nSubmitted batch job 24\n\n$ squeue -o \"%.5i %.2t %.4M %.5D %m\"\nJOBID ST TIME NODES MIN_MEMORY\n  24   R 0:05     1 123\n\nSee also 'squeue --help' and 'man squeue'\n\nscontrol\nThe following job settings can be adjusted using scontrol:\n\n\nRequested Allocation:\n  ReqSockets=<count>  Set the job's count of required sockets\n  ReqCores=<count>    Set the job's count of required cores\n  ReqThreads=<count>  Set the job's count of required threads\n\nFor example:\n\n# scontrol update JobID=17 ReqThreads=2\n# scontrol update JobID=18 ReqCores=4\n# scontrol update JobID=19 ReqSockets=8\n\n% squeue -o '%.5i %.2t %.4M %.5D %9c %7H %6I %8J'\nJOBID ST TIME NODES MIN_PROCS SOCKETS CORES THREADS\n   17 PD 0:00     1 1         4       2     1\n   18 PD 0:00     1 1         8       4     2\n   19 PD 0:00     1 1         4       2     1\n   13  R 1:35     1 0         0       0     0\n   14  R 1:34     1 0         0       0     0\n   15  R 1:34     1 0         0       0     0\n   16  R 1:34     1 0         0       0     0\n\nThe 'scontrol show job' command can be used to display\nthe number of allocated CPUs per node as well as the socket, cores,\nand threads specified in the request and constraints.\n\n\n% srun -N 2 -B 2:1 sleep 100 &\n% scontrol show job 20\nJobId=20 UserId=(30352) GroupId=users(1051)\n   Name=sleep\n   Priority=4294901749 Partition=parts BatchFlag=0\n   AllocNode:Sid=hydra16:3892 TimeLimit=UNLIMITED\n   JobState=RUNNING StartTime=09/25-17:17:30 EndTime=NONE\n   NodeList=hydra[12-14] NodeListIndices=0,2,-1\n   AllocCPUs=1,2,1\n   NumCPUs=4 ReqNodes=2 ReqS:C:T=2:1:*\n   OverSubscribe=0 Contiguous=0 CPUs/task=0\n   MinCPUs=0 MinMemory=0 MinTmpDisk=0 Features=(null)\n   Dependency=0 Account=(null) Reason=None Network=(null)\n   ReqNodeList=(null) ReqNodeListIndices=-1\n   ExcNodeList=(null) ExcNodeListIndices=-1\n   SubmitTime=09/25-17:17:30 SuspendTime=None PreSusTime=0\n\nSee also 'scontrol --help' and 'man scontrol'\n\nConfiguration settings in slurm.conf\n\n\nSeveral slurm.conf settings are available to control the multi-core\nfeatures described above.\n\nIn addition to the description below, also see the \"Task Launch\" and\n\"Resource Selection\" sections if generating slurm.conf\nvia configurator.html.\n\nAs previously mentioned, in order for the affinity to be set, the\ntask/affinity plugin must be first enabled in slurm.conf:\n\n\nTaskPlugin=task/affinity          # enable task affinity\n\nThis setting is part of the task launch specific parameters:\n\n# o Define task launch specific parameters\n#\n#    \"TaskProlog\" : Define a program to be executed as the user before each\n#                   task begins execution.\n#    \"TaskEpilog\" : Define a program to be executed as the user after each\n#                   task terminates.\n#    \"TaskPlugin\" : Define a task launch plugin. This may be used to\n#                   provide resource management within a node (e.g. pinning\n#                   tasks to specific processors). Permissible values are:\n#      \"task/affinity\" : CPU affinity support\n#      \"task/cgroup\"   : bind tasks to resources using Linux cgroup\n#      \"task/none\"     : no task launch actions, the default\n#\n# Example:\n#\n# TaskProlog=/usr/local/slurm/etc/task_prolog # default is none\n# TaskEpilog=/usr/local/slurm/etc/task_epilog # default is none\n# TaskPlugin=task/affinity                    # default is task/none\n\nDeclare the node hardware configuration in slurm.conf:\n\n\nNodeName=dualcore[01-16] CoresPerSocket=2 ThreadsPerCore=1\n\nFor a more complete description of the various node configuration options\nsee the slurm.conf man page.\n\nLast modified 19 May 2023\n"
        },
        {
            "title": "Task distribution options: Extensions to -m / --distribution\n\n",
            "content": "The -m / --distribution option for distributing processes across nodes\nhas been extended to also describe the distribution within the lowest level\nof logical processors.\nAvailable distributions include:\n\narbitrary | block | cyclic | plane=x | [block|cyclic]:[block|cyclic|fcyclic]\nThe  plane distribution (plane=x)\nresults in a block:cyclic distribution of blocksize equal to x.\nIn the following we use \"lowest level of logical processors\"\nto describe sockets, cores or threads depending of the architecture.\nThe distribution divides\nthe cluster into planes (including a number of the lowest level of logical\nprocessors on each node) and then schedule first within each plane and then\nacross planes.For the two dimensional distributions ([block|cyclic]:[block|cyclic|fcyclic]),\nthe second distribution (after \":\") allows users to specify a distribution\nmethod for processes within a node and applies to the lowest level of logical\nprocessors (sockets, core or thread depending on the architecture).\nWhen a task requires more than one CPU, the cyclic will allocate all\nof those CPUs as a group (i.e. within the same socket if possible) while \nfcyclic would distribute each of those CPU of the in a cyclic fashion\nacross sockets.The binding is enabled automatically when high level flags are used as long\nas the task/affinity plug-in is enabled. To disable binding at the job level\nuse --cpu-bind=no.The distribution flags can be combined with the other switches:\n\n\n\nsrun -n 16 -N 4 -B '2:*:1' -m block:cyclic --cpu-bind=socket a.out\nsrun -n 16 -N 4 -B '2:*:1' -m plane=2 --cpu-bind=core a.out\nsrun -n 16 -N 4 -B '2:*:1' -m plane=2 a.out\n\n\nThe default distribution on multi-core/multi-threaded systems is equivalent\nto -m block:cyclic with --cpu-bind=thread.\nSee also 'srun --help'\nMemory as a Consumable Resource\n\n\nThe --mem flag specifies the maximum amount of memory in MB\nneeded by the job per node.  This flag is used to support the memory\nas a consumable resource allocation strategy.\n\n--mem=MB      maximum amount of real memory per node\n              required by the job.\n\nThis flag allows the scheduler to co-allocate jobs on specific nodes\ngiven that their added memory requirement do not exceed the total amount\nof memory on the nodes.\nIn order to use memory as a consumable resource, the select/cons_tres\nplugin must be first enabled in slurm.conf:\n\nSelectType=select/cons_tres     # enable consumable resources\nSelectTypeParameters=CR_Memory  # memory as a consumable resource\n\n Using memory as a consumable resource is typically combined with\nthe CPU, Socket, or Core consumable resources using SelectTypeParameters\nvalues of: CR_CPU_Memory, CR_Socket_Memory or CR_Core_Memory\n\nSee the \"Resource Selection\" section if generating slurm.conf\nvia configurator.html.\n\nSee also 'srun --help' and 'man srun'\nTask invocation as a function of logical processors\n\n\nThe --ntasks-per-{node,socket,core}=ntasks flags\nallow the user to request that no more than ntasks\nbe invoked on each node, socket, or core.\nThis is similar to using --cpus-per-task=ncpus\nbut does not require knowledge of the actual number of cpus on\neach node.  In some cases, it is more convenient to be able to\nrequest that no more than a specific number of ntasks be invoked\non each node, socket, or core.  Examples of this include submitting\nan app where only one \"task/rank\" should be\nassigned to each node while allowing the job to utilize\nall of the parallelism present in the node, or submitting a single\nsetup/cleanup/monitoring job to each node of a pre-existing\nallocation as one step in a larger job script.\nThis can now be specified via the following flags:\n\n--ntasks-per-node=n    number of tasks to invoke on each node\n--ntasks-per-socket=n  number of tasks to invoke on each socket\n--ntasks-per-core=n    number of tasks to invoke on each core\n\nFor example, given a cluster with nodes containing two sockets,\neach containing two cores, the following commands illustrate the\nbehavior of these flags:\n\n% srun -n 4 hostname\nhydra12\nhydra12\nhydra12\nhydra12\n% srun -n 4 --ntasks-per-node=1 hostname\nhydra12\nhydra13\nhydra14\nhydra15\n% srun -n 4 --ntasks-per-node=2 hostname\nhydra12\nhydra12\nhydra13\nhydra13\n% srun -n 4 --ntasks-per-socket=1 hostname\nhydra12\nhydra12\nhydra13\nhydra13\n% srun -n 4 --ntasks-per-core=1 hostname\nhydra12\nhydra12\nhydra12\nhydra12\n\nSee also 'srun --help' and 'man srun'\nApplication hints\n\n\nDifferent applications will have various levels of resource\nrequirements. Some applications tend to be computationally intensive\nbut require little to no inter-process communication. Some applications\nwill be memory bound, saturating the memory bandwidth of a processor\nbefore exhausting the computational capabilities. Other applications\nwill be highly communication intensive causing processes to block\nawaiting messages from other processes. Applications with these\ndifferent properties tend to run well on a multi-core system given\nthe right mappings.\nFor computationally intensive applications, all cores in a multi-core\nsystem would normally be used. For memory bound applications, only\nusing a single core on each socket will result in the highest per\ncore memory bandwidth. For communication intensive applications,\nusing in-core multi-threading (e.g. hyperthreading, SMT, or TMT)\nmay also improve performance.\nThe following command line flags can be used to communicate these\ntypes of application hints to the Slurm multi-core support:\n\n--hint=             Bind tasks according to application hints\n    compute_bound   use all cores in each socket\n    memory_bound    use only one core in each socket\n    [no]multithread [don't] use extra threads with in-core multi-threading\n    help            show this help message\n\nFor example, given a cluster with nodes containing two sockets,\neach containing two cores, the following commands illustrate the\nbehavior of these flags.  In the verbose --cpu-bind output, tasks\nare described as 'hostname, task Global_ID Local_ID [PID]':\n\n% srun -n 4 --hint=compute_bound --cpu-bind=verbose sleep 1\ncpu-bind=MASK - hydra12, task  0  0 [15425]: mask 0x1 set\ncpu-bind=MASK - hydra12, task  1  1 [15426]: mask 0x4 set\ncpu-bind=MASK - hydra12, task  2  2 [15427]: mask 0x2 set\ncpu-bind=MASK - hydra12, task  3  3 [15428]: mask 0x8 set\n\n% srun -n 4 --hint=memory_bound --cpu-bind=verbose sleep 1\ncpu-bind=MASK - hydra12, task  0  0 [15550]: mask 0x1 set\ncpu-bind=MASK - hydra12, task  1  1 [15551]: mask 0x4 set\ncpu-bind=MASK - hydra13, task  2  0 [14974]: mask 0x1 set\ncpu-bind=MASK - hydra13, task  3  1 [14975]: mask 0x4 set\n\nSee also 'srun --hint=help' and 'man srun'\n\nMotivation behind high-level srun flags\n\n\nThe motivation behind allowing users to use higher level srun\nflags instead of --cpu-bind is that the later can be difficult to use. The\nproposed high-level flags are easier to use than --cpu-bind because:\n\nAffinity mask generation happens automatically when using the high-level flags. \nThe length and complexity of the --cpu-bind flag vs. the length\nof the combination of -B and --distribution flags make the high-level\nflags much easier to use.\n\nAlso as illustrated in the example below it is much simpler to specify\na different layout using the high-level flags since users do not have to\nrecalculate mask or CPU IDs. This approach is much simpler than\nrearranging the mask or map.\nGiven a 32-process job and a four node, dual-socket, dual-core\ncluster, we want to use a block distribution across the four nodes and then a\ncyclic distribution within the node across the physical processors. Below we\nshow how to obtain the wanted layout using 1) high-level flags and\n2) --cpubind\nHigh-Level flags\n\n\nUsing Slurm's high-level flag, users can obtain the above layout with\neither of the following submissions since --distribution=block:cyclic\nis the default distribution method.\n\n$ srun -n 32 -N 4 -B 4:2 --distribution=block:cyclic a.out\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0or\n\n$ srun -n 32 -N 4 -B 4:2 a.out\n\nThe cores are shown as c0 and c1 and the processors are shown\nas p0 through p3. The resulting task IDs are: \n\n\n\n\n \nc0c1\np0 0  4 \np2 2  6 \n\n\n\n\n\n\n \nc0c1\np1 1  5 \np3 3  7 \n\n\n\n\nThe computation and assignment of the task IDs is transparent\nto the user. Users don't have to worry about the core numbering (Section\nPinning processes to cores) or any setting any CPU affinities. By default CPU affinity\nwill be set when using multi-core supporting flags. \nLow-level flag --cpu-bind\n\n\nUsing Slurm's --cpu-bind flag, users must compute the CPU IDs or\nmasks as well as make sure they understand the core numbering on their\nsystem. Another problem arises when core numbering is not the same on all\nnodes. The --cpu-bind option only allows users to specify a single\nmask for all the nodes. Using Slurm high-level flags remove this limitation\nsince Slurm will correctly generate the appropriate masks for each requested nodes.\n\nOn a four dual-socket dual-core node cluster with core block numbering\n\n\nThe cores are shown as c0 and c1 and the processors are shown\nas p0 through p3. The CPU IDs within a node in the block numbering are:\n(this information is available from the /proc/cpuinfo file on the system)\n\n\n\n\n \nc0c1\np0 0  1 \np2 4  5 \n\n\n\n\n\n\n \nc0c1\np1 2  3 \np3 6  7 \n\n\n\n\n\u00a0resulting in the following mapping for processor/cores\nand task IDs which users need to calculate: \n\nmapping for processors/cores\n\n\n\n\n\n \nc0c1\np0 0x01  0x02 \np2 0x10  0x20 \n\n\n\n\n\n\n \nc0c1\np1 0x04  0x08 \np3 0x40  0x80 \n\n\n\n\n\n\ntask IDs\n\n\n\n\n\n \nc0c1\np0 0  4 \np2 2  6 \n\n\n\n\n\n\n \nc0c1\np1 1  5 \np3 3  7 \n\n\n\n\nThe above maps and task IDs can be translated into the\nfollowing command:\n\n$ srun -n 32 -N 4 --cpu-bind=mask_cpu:1,4,10,40,2,8,20,80 a.out\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0or\n\n$ srun -n 32 -N 4 --cpu-bind=map_cpu:0,2,4,6,1,3,5,7 a.out\n\n\nSame cluster but with its core numbered cyclic instead of block\n\n\nOn a system with cyclically numbered cores, the correct mask\nargument to the srun command looks like: (this will\nachieve the same layout as the command above on a system with core block\nnumbering.)\n\n$ srun -n 32 -N 4 --cpu-bind=map_cpu:0,1,2,3,4,5,6,7 a.out\n\nBlock map_cpu on a system with cyclic core numbering\n\n\nIf users do not check their system's core numbering before specifying\nthe map_cpu list and thereby do not realize that the system has cyclic core\nnumbering instead of block numbering then they will not get the expected\nlayout. For example, if they decide to re-use their command from above:\n\n$ srun -n 32 -N 4 --cpu-bind=map_cpu:0,2,4,6,1,3,5,7 a.out\n\nthey get the following unintentional task ID layout:\n\n\n\n\n \nc0c1\np0 0  2 \np2 1  3 \n\n\n\n\n\n\n \nc0c1\np1 4  6 \np3 5  7 \n\n\n\n\nsince the processor IDs within a node in the cyclic numbering are:\n\n\n\n\n \nc0c1\np0 0  4 \np2 2  6 \n\n\n\n\n\n\n \nc0c1\np1 1  5 \np3 3  7 \n\n\n\n\nThe important conclusion is that using the --cpu-bind flag is not\ntrivial and that it assumes that users are experts.\n\nExtensions to sinfo/squeue/scontrol\n\n\nSeveral extensions have also been made to the other Slurm utilities to\nmake working with multi-core/multi-threaded systems easier.\n\nsinfo\nThe long version (-l) of the sinfo node listing (-N) has been\nextended to display the sockets, cores, and threads present for each\nnode.  For example:\n\n\n% sinfo -N\nNODELIST     NODES PARTITION STATE\nhydra[12-15]     4    parts* idle\n\n% sinfo -lN\nThu Sep 14 17:47:13 2006\nNODELIST     NODES PARTITION       STATE CPUS    S:C:T MEMORY TMP_DISK WEIGHT FEATURES REASON\nhydra[12-15]     4    parts*        idle   8+ 2+:4+:1+   2007    41447      1   (null) none\n\n% sinfo -lNe\nThu Sep 14 17:47:18 2006\nNODELIST     NODES PARTITION       STATE CPUS    S:C:T MEMORY TMP_DISK WEIGHT FEATURES REASON\n\nhydra[12-14]     3    parts*        idle    8    2:4:1   2007    41447      1   (null) none\nhydra15          1    parts*        idle   64    8:4:2   2007    41447      1   (null) none\n\nFor user specified output formats (-o/--format) and sorting (-S/--sort),\nthe following identifiers are available:\n\n%X  Number of sockets per node\n%Y  Number of cores per socket\n%Z  Number of threads per core\n%z  Extended processor information: number of\n    sockets, core, threads (S:C:T) per node\n\nFor example:\n\n% sinfo -o '%9P %4c %8z %8X %8Y %8Z'\nPARTITION CPUS S:C:T    SOCKETS  CORES    THREADS\nparts*    4    2:2:1    2        2        1\n\nSee also 'sinfo --help' and 'man sinfo'\n\nsqueue\nFor user specified output formats (-o/--format) and sorting (-S/--sort),\nthe following identifiers are available:\n\n%m  Size of memory (in MB) requested by the job\n%H  Number of requested sockets per node\n%I  Number of requested cores per socket\n%J  Number of requested threads per core\n%z  Extended processor information: number of requested\n    sockets, cores, threads (S:C:T) per node\n\nBelow is an example squeue output after running 7 copies of:\n\n\n% srun -n 4 -B 2:2:1 --mem=1024 sleep 100 &\n\n\n\n% squeue -o '%.5i %.2t %.4M %.5D %7H %6I %7J %6z %R'\nJOBID ST TIME NODES SOCKETS CORES THREADS S:C:T NODELIST(REASON)\n   17 PD 0:00     1 2       2     1       2:2:1 (Resources)\n   18 PD 0:00     1 2       2     1       2:2:1 (Resources)\n   19 PD 0:00     1 2       2     1       2:2:1 (Resources)\n   13  R 1:27     1 2       2     1       2:2:1 hydra12\n   14  R 1:26     1 2       2     1       2:2:1 hydra13\n   15  R 1:26     1 2       2     1       2:2:1 hydra14\n   16  R 1:26     1 2       2     1       2:2:1 hydra15\n\nThe squeue command can also display the memory size of jobs, for example:\n\n% sbatch --mem=123 tmp\nSubmitted batch job 24\n\n$ squeue -o \"%.5i %.2t %.4M %.5D %m\"\nJOBID ST TIME NODES MIN_MEMORY\n  24   R 0:05     1 123\n\nSee also 'squeue --help' and 'man squeue'\n\nscontrol\nThe following job settings can be adjusted using scontrol:\n\n\nRequested Allocation:\n  ReqSockets=<count>  Set the job's count of required sockets\n  ReqCores=<count>    Set the job's count of required cores\n  ReqThreads=<count>  Set the job's count of required threads\n\nFor example:\n\n# scontrol update JobID=17 ReqThreads=2\n# scontrol update JobID=18 ReqCores=4\n# scontrol update JobID=19 ReqSockets=8\n\n% squeue -o '%.5i %.2t %.4M %.5D %9c %7H %6I %8J'\nJOBID ST TIME NODES MIN_PROCS SOCKETS CORES THREADS\n   17 PD 0:00     1 1         4       2     1\n   18 PD 0:00     1 1         8       4     2\n   19 PD 0:00     1 1         4       2     1\n   13  R 1:35     1 0         0       0     0\n   14  R 1:34     1 0         0       0     0\n   15  R 1:34     1 0         0       0     0\n   16  R 1:34     1 0         0       0     0\n\nThe 'scontrol show job' command can be used to display\nthe number of allocated CPUs per node as well as the socket, cores,\nand threads specified in the request and constraints.\n\n\n% srun -N 2 -B 2:1 sleep 100 &\n% scontrol show job 20\nJobId=20 UserId=(30352) GroupId=users(1051)\n   Name=sleep\n   Priority=4294901749 Partition=parts BatchFlag=0\n   AllocNode:Sid=hydra16:3892 TimeLimit=UNLIMITED\n   JobState=RUNNING StartTime=09/25-17:17:30 EndTime=NONE\n   NodeList=hydra[12-14] NodeListIndices=0,2,-1\n   AllocCPUs=1,2,1\n   NumCPUs=4 ReqNodes=2 ReqS:C:T=2:1:*\n   OverSubscribe=0 Contiguous=0 CPUs/task=0\n   MinCPUs=0 MinMemory=0 MinTmpDisk=0 Features=(null)\n   Dependency=0 Account=(null) Reason=None Network=(null)\n   ReqNodeList=(null) ReqNodeListIndices=-1\n   ExcNodeList=(null) ExcNodeListIndices=-1\n   SubmitTime=09/25-17:17:30 SuspendTime=None PreSusTime=0\n\nSee also 'scontrol --help' and 'man scontrol'\n\nConfiguration settings in slurm.conf\n\n\nSeveral slurm.conf settings are available to control the multi-core\nfeatures described above.\n\nIn addition to the description below, also see the \"Task Launch\" and\n\"Resource Selection\" sections if generating slurm.conf\nvia configurator.html.\n\nAs previously mentioned, in order for the affinity to be set, the\ntask/affinity plugin must be first enabled in slurm.conf:\n\n\nTaskPlugin=task/affinity          # enable task affinity\n\nThis setting is part of the task launch specific parameters:\n\n# o Define task launch specific parameters\n#\n#    \"TaskProlog\" : Define a program to be executed as the user before each\n#                   task begins execution.\n#    \"TaskEpilog\" : Define a program to be executed as the user after each\n#                   task terminates.\n#    \"TaskPlugin\" : Define a task launch plugin. This may be used to\n#                   provide resource management within a node (e.g. pinning\n#                   tasks to specific processors). Permissible values are:\n#      \"task/affinity\" : CPU affinity support\n#      \"task/cgroup\"   : bind tasks to resources using Linux cgroup\n#      \"task/none\"     : no task launch actions, the default\n#\n# Example:\n#\n# TaskProlog=/usr/local/slurm/etc/task_prolog # default is none\n# TaskEpilog=/usr/local/slurm/etc/task_epilog # default is none\n# TaskPlugin=task/affinity                    # default is task/none\n\nDeclare the node hardware configuration in slurm.conf:\n\n\nNodeName=dualcore[01-16] CoresPerSocket=2 ThreadsPerCore=1\n\nFor a more complete description of the various node configuration options\nsee the slurm.conf man page.\n\nLast modified 19 May 2023\n"
        },
        {
            "title": "Memory as a Consumable Resource\n\n",
            "content": "The --mem flag specifies the maximum amount of memory in MB\nneeded by the job per node.  This flag is used to support the memory\nas a consumable resource allocation strategy.\n--mem=MB      maximum amount of real memory per node\n              required by the job.\nThis flag allows the scheduler to co-allocate jobs on specific nodes\ngiven that their added memory requirement do not exceed the total amount\nof memory on the nodes.In order to use memory as a consumable resource, the select/cons_tres\nplugin must be first enabled in slurm.conf:\n\nSelectType=select/cons_tres     # enable consumable resources\nSelectTypeParameters=CR_Memory  # memory as a consumable resource\n\n Using memory as a consumable resource is typically combined with\nthe CPU, Socket, or Core consumable resources using SelectTypeParameters\nvalues of: CR_CPU_Memory, CR_Socket_Memory or CR_Core_Memory\n\nSee the \"Resource Selection\" section if generating slurm.conf\nvia configurator.html.\n\nSee also 'srun --help' and 'man srun'\nTask invocation as a function of logical processors\n\n\nThe --ntasks-per-{node,socket,core}=ntasks flags\nallow the user to request that no more than ntasks\nbe invoked on each node, socket, or core.\nThis is similar to using --cpus-per-task=ncpus\nbut does not require knowledge of the actual number of cpus on\neach node.  In some cases, it is more convenient to be able to\nrequest that no more than a specific number of ntasks be invoked\non each node, socket, or core.  Examples of this include submitting\nan app where only one \"task/rank\" should be\nassigned to each node while allowing the job to utilize\nall of the parallelism present in the node, or submitting a single\nsetup/cleanup/monitoring job to each node of a pre-existing\nallocation as one step in a larger job script.\nThis can now be specified via the following flags:\n\n--ntasks-per-node=n    number of tasks to invoke on each node\n--ntasks-per-socket=n  number of tasks to invoke on each socket\n--ntasks-per-core=n    number of tasks to invoke on each core\n\nFor example, given a cluster with nodes containing two sockets,\neach containing two cores, the following commands illustrate the\nbehavior of these flags:\n\n% srun -n 4 hostname\nhydra12\nhydra12\nhydra12\nhydra12\n% srun -n 4 --ntasks-per-node=1 hostname\nhydra12\nhydra13\nhydra14\nhydra15\n% srun -n 4 --ntasks-per-node=2 hostname\nhydra12\nhydra12\nhydra13\nhydra13\n% srun -n 4 --ntasks-per-socket=1 hostname\nhydra12\nhydra12\nhydra13\nhydra13\n% srun -n 4 --ntasks-per-core=1 hostname\nhydra12\nhydra12\nhydra12\nhydra12\n\nSee also 'srun --help' and 'man srun'\nApplication hints\n\n\nDifferent applications will have various levels of resource\nrequirements. Some applications tend to be computationally intensive\nbut require little to no inter-process communication. Some applications\nwill be memory bound, saturating the memory bandwidth of a processor\nbefore exhausting the computational capabilities. Other applications\nwill be highly communication intensive causing processes to block\nawaiting messages from other processes. Applications with these\ndifferent properties tend to run well on a multi-core system given\nthe right mappings.\nFor computationally intensive applications, all cores in a multi-core\nsystem would normally be used. For memory bound applications, only\nusing a single core on each socket will result in the highest per\ncore memory bandwidth. For communication intensive applications,\nusing in-core multi-threading (e.g. hyperthreading, SMT, or TMT)\nmay also improve performance.\nThe following command line flags can be used to communicate these\ntypes of application hints to the Slurm multi-core support:\n\n--hint=             Bind tasks according to application hints\n    compute_bound   use all cores in each socket\n    memory_bound    use only one core in each socket\n    [no]multithread [don't] use extra threads with in-core multi-threading\n    help            show this help message\n\nFor example, given a cluster with nodes containing two sockets,\neach containing two cores, the following commands illustrate the\nbehavior of these flags.  In the verbose --cpu-bind output, tasks\nare described as 'hostname, task Global_ID Local_ID [PID]':\n\n% srun -n 4 --hint=compute_bound --cpu-bind=verbose sleep 1\ncpu-bind=MASK - hydra12, task  0  0 [15425]: mask 0x1 set\ncpu-bind=MASK - hydra12, task  1  1 [15426]: mask 0x4 set\ncpu-bind=MASK - hydra12, task  2  2 [15427]: mask 0x2 set\ncpu-bind=MASK - hydra12, task  3  3 [15428]: mask 0x8 set\n\n% srun -n 4 --hint=memory_bound --cpu-bind=verbose sleep 1\ncpu-bind=MASK - hydra12, task  0  0 [15550]: mask 0x1 set\ncpu-bind=MASK - hydra12, task  1  1 [15551]: mask 0x4 set\ncpu-bind=MASK - hydra13, task  2  0 [14974]: mask 0x1 set\ncpu-bind=MASK - hydra13, task  3  1 [14975]: mask 0x4 set\n\nSee also 'srun --hint=help' and 'man srun'\n\nMotivation behind high-level srun flags\n\n\nThe motivation behind allowing users to use higher level srun\nflags instead of --cpu-bind is that the later can be difficult to use. The\nproposed high-level flags are easier to use than --cpu-bind because:\n\nAffinity mask generation happens automatically when using the high-level flags. \nThe length and complexity of the --cpu-bind flag vs. the length\nof the combination of -B and --distribution flags make the high-level\nflags much easier to use.\n\nAlso as illustrated in the example below it is much simpler to specify\na different layout using the high-level flags since users do not have to\nrecalculate mask or CPU IDs. This approach is much simpler than\nrearranging the mask or map.\nGiven a 32-process job and a four node, dual-socket, dual-core\ncluster, we want to use a block distribution across the four nodes and then a\ncyclic distribution within the node across the physical processors. Below we\nshow how to obtain the wanted layout using 1) high-level flags and\n2) --cpubind\nHigh-Level flags\n\n\nUsing Slurm's high-level flag, users can obtain the above layout with\neither of the following submissions since --distribution=block:cyclic\nis the default distribution method.\n\n$ srun -n 32 -N 4 -B 4:2 --distribution=block:cyclic a.out\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0or\n\n$ srun -n 32 -N 4 -B 4:2 a.out\n\nThe cores are shown as c0 and c1 and the processors are shown\nas p0 through p3. The resulting task IDs are: \n\n\n\n\n \nc0c1\np0 0  4 \np2 2  6 \n\n\n\n\n\n\n \nc0c1\np1 1  5 \np3 3  7 \n\n\n\n\nThe computation and assignment of the task IDs is transparent\nto the user. Users don't have to worry about the core numbering (Section\nPinning processes to cores) or any setting any CPU affinities. By default CPU affinity\nwill be set when using multi-core supporting flags. \nLow-level flag --cpu-bind\n\n\nUsing Slurm's --cpu-bind flag, users must compute the CPU IDs or\nmasks as well as make sure they understand the core numbering on their\nsystem. Another problem arises when core numbering is not the same on all\nnodes. The --cpu-bind option only allows users to specify a single\nmask for all the nodes. Using Slurm high-level flags remove this limitation\nsince Slurm will correctly generate the appropriate masks for each requested nodes.\n\nOn a four dual-socket dual-core node cluster with core block numbering\n\n\nThe cores are shown as c0 and c1 and the processors are shown\nas p0 through p3. The CPU IDs within a node in the block numbering are:\n(this information is available from the /proc/cpuinfo file on the system)\n\n\n\n\n \nc0c1\np0 0  1 \np2 4  5 \n\n\n\n\n\n\n \nc0c1\np1 2  3 \np3 6  7 \n\n\n\n\n\u00a0resulting in the following mapping for processor/cores\nand task IDs which users need to calculate: \n\nmapping for processors/cores\n\n\n\n\n\n \nc0c1\np0 0x01  0x02 \np2 0x10  0x20 \n\n\n\n\n\n\n \nc0c1\np1 0x04  0x08 \np3 0x40  0x80 \n\n\n\n\n\n\ntask IDs\n\n\n\n\n\n \nc0c1\np0 0  4 \np2 2  6 \n\n\n\n\n\n\n \nc0c1\np1 1  5 \np3 3  7 \n\n\n\n\nThe above maps and task IDs can be translated into the\nfollowing command:\n\n$ srun -n 32 -N 4 --cpu-bind=mask_cpu:1,4,10,40,2,8,20,80 a.out\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0or\n\n$ srun -n 32 -N 4 --cpu-bind=map_cpu:0,2,4,6,1,3,5,7 a.out\n\n\nSame cluster but with its core numbered cyclic instead of block\n\n\nOn a system with cyclically numbered cores, the correct mask\nargument to the srun command looks like: (this will\nachieve the same layout as the command above on a system with core block\nnumbering.)\n\n$ srun -n 32 -N 4 --cpu-bind=map_cpu:0,1,2,3,4,5,6,7 a.out\n\nBlock map_cpu on a system with cyclic core numbering\n\n\nIf users do not check their system's core numbering before specifying\nthe map_cpu list and thereby do not realize that the system has cyclic core\nnumbering instead of block numbering then they will not get the expected\nlayout. For example, if they decide to re-use their command from above:\n\n$ srun -n 32 -N 4 --cpu-bind=map_cpu:0,2,4,6,1,3,5,7 a.out\n\nthey get the following unintentional task ID layout:\n\n\n\n\n \nc0c1\np0 0  2 \np2 1  3 \n\n\n\n\n\n\n \nc0c1\np1 4  6 \np3 5  7 \n\n\n\n\nsince the processor IDs within a node in the cyclic numbering are:\n\n\n\n\n \nc0c1\np0 0  4 \np2 2  6 \n\n\n\n\n\n\n \nc0c1\np1 1  5 \np3 3  7 \n\n\n\n\nThe important conclusion is that using the --cpu-bind flag is not\ntrivial and that it assumes that users are experts.\n\nExtensions to sinfo/squeue/scontrol\n\n\nSeveral extensions have also been made to the other Slurm utilities to\nmake working with multi-core/multi-threaded systems easier.\n\nsinfo\nThe long version (-l) of the sinfo node listing (-N) has been\nextended to display the sockets, cores, and threads present for each\nnode.  For example:\n\n\n% sinfo -N\nNODELIST     NODES PARTITION STATE\nhydra[12-15]     4    parts* idle\n\n% sinfo -lN\nThu Sep 14 17:47:13 2006\nNODELIST     NODES PARTITION       STATE CPUS    S:C:T MEMORY TMP_DISK WEIGHT FEATURES REASON\nhydra[12-15]     4    parts*        idle   8+ 2+:4+:1+   2007    41447      1   (null) none\n\n% sinfo -lNe\nThu Sep 14 17:47:18 2006\nNODELIST     NODES PARTITION       STATE CPUS    S:C:T MEMORY TMP_DISK WEIGHT FEATURES REASON\n\nhydra[12-14]     3    parts*        idle    8    2:4:1   2007    41447      1   (null) none\nhydra15          1    parts*        idle   64    8:4:2   2007    41447      1   (null) none\n\nFor user specified output formats (-o/--format) and sorting (-S/--sort),\nthe following identifiers are available:\n\n%X  Number of sockets per node\n%Y  Number of cores per socket\n%Z  Number of threads per core\n%z  Extended processor information: number of\n    sockets, core, threads (S:C:T) per node\n\nFor example:\n\n% sinfo -o '%9P %4c %8z %8X %8Y %8Z'\nPARTITION CPUS S:C:T    SOCKETS  CORES    THREADS\nparts*    4    2:2:1    2        2        1\n\nSee also 'sinfo --help' and 'man sinfo'\n\nsqueue\nFor user specified output formats (-o/--format) and sorting (-S/--sort),\nthe following identifiers are available:\n\n%m  Size of memory (in MB) requested by the job\n%H  Number of requested sockets per node\n%I  Number of requested cores per socket\n%J  Number of requested threads per core\n%z  Extended processor information: number of requested\n    sockets, cores, threads (S:C:T) per node\n\nBelow is an example squeue output after running 7 copies of:\n\n\n% srun -n 4 -B 2:2:1 --mem=1024 sleep 100 &\n\n\n\n% squeue -o '%.5i %.2t %.4M %.5D %7H %6I %7J %6z %R'\nJOBID ST TIME NODES SOCKETS CORES THREADS S:C:T NODELIST(REASON)\n   17 PD 0:00     1 2       2     1       2:2:1 (Resources)\n   18 PD 0:00     1 2       2     1       2:2:1 (Resources)\n   19 PD 0:00     1 2       2     1       2:2:1 (Resources)\n   13  R 1:27     1 2       2     1       2:2:1 hydra12\n   14  R 1:26     1 2       2     1       2:2:1 hydra13\n   15  R 1:26     1 2       2     1       2:2:1 hydra14\n   16  R 1:26     1 2       2     1       2:2:1 hydra15\n\nThe squeue command can also display the memory size of jobs, for example:\n\n% sbatch --mem=123 tmp\nSubmitted batch job 24\n\n$ squeue -o \"%.5i %.2t %.4M %.5D %m\"\nJOBID ST TIME NODES MIN_MEMORY\n  24   R 0:05     1 123\n\nSee also 'squeue --help' and 'man squeue'\n\nscontrol\nThe following job settings can be adjusted using scontrol:\n\n\nRequested Allocation:\n  ReqSockets=<count>  Set the job's count of required sockets\n  ReqCores=<count>    Set the job's count of required cores\n  ReqThreads=<count>  Set the job's count of required threads\n\nFor example:\n\n# scontrol update JobID=17 ReqThreads=2\n# scontrol update JobID=18 ReqCores=4\n# scontrol update JobID=19 ReqSockets=8\n\n% squeue -o '%.5i %.2t %.4M %.5D %9c %7H %6I %8J'\nJOBID ST TIME NODES MIN_PROCS SOCKETS CORES THREADS\n   17 PD 0:00     1 1         4       2     1\n   18 PD 0:00     1 1         8       4     2\n   19 PD 0:00     1 1         4       2     1\n   13  R 1:35     1 0         0       0     0\n   14  R 1:34     1 0         0       0     0\n   15  R 1:34     1 0         0       0     0\n   16  R 1:34     1 0         0       0     0\n\nThe 'scontrol show job' command can be used to display\nthe number of allocated CPUs per node as well as the socket, cores,\nand threads specified in the request and constraints.\n\n\n% srun -N 2 -B 2:1 sleep 100 &\n% scontrol show job 20\nJobId=20 UserId=(30352) GroupId=users(1051)\n   Name=sleep\n   Priority=4294901749 Partition=parts BatchFlag=0\n   AllocNode:Sid=hydra16:3892 TimeLimit=UNLIMITED\n   JobState=RUNNING StartTime=09/25-17:17:30 EndTime=NONE\n   NodeList=hydra[12-14] NodeListIndices=0,2,-1\n   AllocCPUs=1,2,1\n   NumCPUs=4 ReqNodes=2 ReqS:C:T=2:1:*\n   OverSubscribe=0 Contiguous=0 CPUs/task=0\n   MinCPUs=0 MinMemory=0 MinTmpDisk=0 Features=(null)\n   Dependency=0 Account=(null) Reason=None Network=(null)\n   ReqNodeList=(null) ReqNodeListIndices=-1\n   ExcNodeList=(null) ExcNodeListIndices=-1\n   SubmitTime=09/25-17:17:30 SuspendTime=None PreSusTime=0\n\nSee also 'scontrol --help' and 'man scontrol'\n\nConfiguration settings in slurm.conf\n\n\nSeveral slurm.conf settings are available to control the multi-core\nfeatures described above.\n\nIn addition to the description below, also see the \"Task Launch\" and\n\"Resource Selection\" sections if generating slurm.conf\nvia configurator.html.\n\nAs previously mentioned, in order for the affinity to be set, the\ntask/affinity plugin must be first enabled in slurm.conf:\n\n\nTaskPlugin=task/affinity          # enable task affinity\n\nThis setting is part of the task launch specific parameters:\n\n# o Define task launch specific parameters\n#\n#    \"TaskProlog\" : Define a program to be executed as the user before each\n#                   task begins execution.\n#    \"TaskEpilog\" : Define a program to be executed as the user after each\n#                   task terminates.\n#    \"TaskPlugin\" : Define a task launch plugin. This may be used to\n#                   provide resource management within a node (e.g. pinning\n#                   tasks to specific processors). Permissible values are:\n#      \"task/affinity\" : CPU affinity support\n#      \"task/cgroup\"   : bind tasks to resources using Linux cgroup\n#      \"task/none\"     : no task launch actions, the default\n#\n# Example:\n#\n# TaskProlog=/usr/local/slurm/etc/task_prolog # default is none\n# TaskEpilog=/usr/local/slurm/etc/task_epilog # default is none\n# TaskPlugin=task/affinity                    # default is task/none\n\nDeclare the node hardware configuration in slurm.conf:\n\n\nNodeName=dualcore[01-16] CoresPerSocket=2 ThreadsPerCore=1\n\nFor a more complete description of the various node configuration options\nsee the slurm.conf man page.\n\nLast modified 19 May 2023\n"
        },
        {
            "title": "Task invocation as a function of logical processors\n\n",
            "content": "The --ntasks-per-{node,socket,core}=ntasks flags\nallow the user to request that no more than ntasks\nbe invoked on each node, socket, or core.\nThis is similar to using --cpus-per-task=ncpus\nbut does not require knowledge of the actual number of cpus on\neach node.  In some cases, it is more convenient to be able to\nrequest that no more than a specific number of ntasks be invoked\non each node, socket, or core.  Examples of this include submitting\nan app where only one \"task/rank\" should be\nassigned to each node while allowing the job to utilize\nall of the parallelism present in the node, or submitting a single\nsetup/cleanup/monitoring job to each node of a pre-existing\nallocation as one step in a larger job script.\nThis can now be specified via the following flags:\n--ntasks-per-node=n    number of tasks to invoke on each node\n--ntasks-per-socket=n  number of tasks to invoke on each socket\n--ntasks-per-core=n    number of tasks to invoke on each core\nFor example, given a cluster with nodes containing two sockets,\neach containing two cores, the following commands illustrate the\nbehavior of these flags:\n% srun -n 4 hostname\nhydra12\nhydra12\nhydra12\nhydra12\n% srun -n 4 --ntasks-per-node=1 hostname\nhydra12\nhydra13\nhydra14\nhydra15\n% srun -n 4 --ntasks-per-node=2 hostname\nhydra12\nhydra12\nhydra13\nhydra13\n% srun -n 4 --ntasks-per-socket=1 hostname\nhydra12\nhydra12\nhydra13\nhydra13\n% srun -n 4 --ntasks-per-core=1 hostname\nhydra12\nhydra12\nhydra12\nhydra12\nSee also 'srun --help' and 'man srun'Application hints\n\nDifferent applications will have various levels of resource\nrequirements. Some applications tend to be computationally intensive\nbut require little to no inter-process communication. Some applications\nwill be memory bound, saturating the memory bandwidth of a processor\nbefore exhausting the computational capabilities. Other applications\nwill be highly communication intensive causing processes to block\nawaiting messages from other processes. Applications with these\ndifferent properties tend to run well on a multi-core system given\nthe right mappings.For computationally intensive applications, all cores in a multi-core\nsystem would normally be used. For memory bound applications, only\nusing a single core on each socket will result in the highest per\ncore memory bandwidth. For communication intensive applications,\nusing in-core multi-threading (e.g. hyperthreading, SMT, or TMT)\nmay also improve performance.\nThe following command line flags can be used to communicate these\ntypes of application hints to the Slurm multi-core support:\n--hint=             Bind tasks according to application hints\n    compute_bound   use all cores in each socket\n    memory_bound    use only one core in each socket\n    [no]multithread [don't] use extra threads with in-core multi-threading\n    help            show this help message\nFor example, given a cluster with nodes containing two sockets,\neach containing two cores, the following commands illustrate the\nbehavior of these flags.  In the verbose --cpu-bind output, tasks\nare described as 'hostname, task Global_ID Local_ID [PID]':\n% srun -n 4 --hint=compute_bound --cpu-bind=verbose sleep 1\ncpu-bind=MASK - hydra12, task  0  0 [15425]: mask 0x1 set\ncpu-bind=MASK - hydra12, task  1  1 [15426]: mask 0x4 set\ncpu-bind=MASK - hydra12, task  2  2 [15427]: mask 0x2 set\ncpu-bind=MASK - hydra12, task  3  3 [15428]: mask 0x8 set\n\n% srun -n 4 --hint=memory_bound --cpu-bind=verbose sleep 1\ncpu-bind=MASK - hydra12, task  0  0 [15550]: mask 0x1 set\ncpu-bind=MASK - hydra12, task  1  1 [15551]: mask 0x4 set\ncpu-bind=MASK - hydra13, task  2  0 [14974]: mask 0x1 set\ncpu-bind=MASK - hydra13, task  3  1 [14975]: mask 0x4 set\nSee also 'srun --hint=help' and 'man srun'Motivation behind high-level srun flags\n\nThe motivation behind allowing users to use higher level srun\nflags instead of --cpu-bind is that the later can be difficult to use. The\nproposed high-level flags are easier to use than --cpu-bind because:\nAffinity mask generation happens automatically when using the high-level flags. \nThe length and complexity of the --cpu-bind flag vs. the length\nof the combination of -B and --distribution flags make the high-level\nflags much easier to use.\nAlso as illustrated in the example below it is much simpler to specify\na different layout using the high-level flags since users do not have to\nrecalculate mask or CPU IDs. This approach is much simpler than\nrearranging the mask or map.Given a 32-process job and a four node, dual-socket, dual-core\ncluster, we want to use a block distribution across the four nodes and then a\ncyclic distribution within the node across the physical processors. Below we\nshow how to obtain the wanted layout using 1) high-level flags and\n2) --cpubindHigh-Level flags\n\nUsing Slurm's high-level flag, users can obtain the above layout with\neither of the following submissions since --distribution=block:cyclic\nis the default distribution method.\n$ srun -n 32 -N 4 -B 4:2 --distribution=block:cyclic a.out\n\n$ srun -n 32 -N 4 -B 4:2 a.out\nThe cores are shown as c0 and c1 and the processors are shown\nas p0 through p3. The resulting task IDs are: \n\n\n\n \nc0c1\np0 0  4 \np2 2  6 \n\n\n\n\n\n\n \nc0c1\np1 1  5 \np3 3  7 \n\n\n\nThe computation and assignment of the task IDs is transparent\nto the user. Users don't have to worry about the core numbering (Section\nPinning processes to cores) or any setting any CPU affinities. By default CPU affinity\nwill be set when using multi-core supporting flags. Low-level flag --cpu-bind\n\nUsing Slurm's --cpu-bind flag, users must compute the CPU IDs or\nmasks as well as make sure they understand the core numbering on their\nsystem. Another problem arises when core numbering is not the same on all\nnodes. The --cpu-bind option only allows users to specify a single\nmask for all the nodes. Using Slurm high-level flags remove this limitation\nsince Slurm will correctly generate the appropriate masks for each requested nodes.\nOn a four dual-socket dual-core node cluster with core block numbering\n\nThe cores are shown as c0 and c1 and the processors are shown\nas p0 through p3. The CPU IDs within a node in the block numbering are:\n(this information is available from the /proc/cpuinfo file on the system)\n\n\n\n \nc0c1\np0 0  1 \np2 4  5 \n\n\n\n\n\n\n \nc0c1\np1 2  3 \np3 6  7 \n\n\n\n\u00a0resulting in the following mapping for processor/cores\nand task IDs which users need to calculate: \nmapping for processors/cores\n\n\n\n\n \nc0c1\np0 0x01  0x02 \np2 0x10  0x20 \n\n\n\n\n\n\n \nc0c1\np1 0x04  0x08 \np3 0x40  0x80 \n\n\n\n\n\ntask IDs\n\n\n\n\n\n \nc0c1\np0 0  4 \np2 2  6 \n\n\n\n\n\n\n \nc0c1\np1 1  5 \np3 3  7 \n\n\n\n\nThe above maps and task IDs can be translated into the\nfollowing command:\n\n$ srun -n 32 -N 4 --cpu-bind=mask_cpu:1,4,10,40,2,8,20,80 a.out\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0or\n\n$ srun -n 32 -N 4 --cpu-bind=map_cpu:0,2,4,6,1,3,5,7 a.out\n\n\nSame cluster but with its core numbered cyclic instead of block\n\n\nOn a system with cyclically numbered cores, the correct mask\nargument to the srun command looks like: (this will\nachieve the same layout as the command above on a system with core block\nnumbering.)\n\n$ srun -n 32 -N 4 --cpu-bind=map_cpu:0,1,2,3,4,5,6,7 a.out\n\nBlock map_cpu on a system with cyclic core numbering\n\n\nIf users do not check their system's core numbering before specifying\nthe map_cpu list and thereby do not realize that the system has cyclic core\nnumbering instead of block numbering then they will not get the expected\nlayout. For example, if they decide to re-use their command from above:\n\n$ srun -n 32 -N 4 --cpu-bind=map_cpu:0,2,4,6,1,3,5,7 a.out\n\nthey get the following unintentional task ID layout:\n\n\n\n\n \nc0c1\np0 0  2 \np2 1  3 \n\n\n\n\n\n\n \nc0c1\np1 4  6 \np3 5  7 \n\n\n\n\nsince the processor IDs within a node in the cyclic numbering are:\n\n\n\n\n \nc0c1\np0 0  4 \np2 2  6 \n\n\n\n\n\n\n \nc0c1\np1 1  5 \np3 3  7 \n\n\n\n\nThe important conclusion is that using the --cpu-bind flag is not\ntrivial and that it assumes that users are experts.\n\nExtensions to sinfo/squeue/scontrol\n\n\nSeveral extensions have also been made to the other Slurm utilities to\nmake working with multi-core/multi-threaded systems easier.\n\nsinfo\nThe long version (-l) of the sinfo node listing (-N) has been\nextended to display the sockets, cores, and threads present for each\nnode.  For example:\n\n\n% sinfo -N\nNODELIST     NODES PARTITION STATE\nhydra[12-15]     4    parts* idle\n\n% sinfo -lN\nThu Sep 14 17:47:13 2006\nNODELIST     NODES PARTITION       STATE CPUS    S:C:T MEMORY TMP_DISK WEIGHT FEATURES REASON\nhydra[12-15]     4    parts*        idle   8+ 2+:4+:1+   2007    41447      1   (null) none\n\n% sinfo -lNe\nThu Sep 14 17:47:18 2006\nNODELIST     NODES PARTITION       STATE CPUS    S:C:T MEMORY TMP_DISK WEIGHT FEATURES REASON\n\nhydra[12-14]     3    parts*        idle    8    2:4:1   2007    41447      1   (null) none\nhydra15          1    parts*        idle   64    8:4:2   2007    41447      1   (null) none\n\nFor user specified output formats (-o/--format) and sorting (-S/--sort),\nthe following identifiers are available:\n\n%X  Number of sockets per node\n%Y  Number of cores per socket\n%Z  Number of threads per core\n%z  Extended processor information: number of\n    sockets, core, threads (S:C:T) per node\n\nFor example:\n\n% sinfo -o '%9P %4c %8z %8X %8Y %8Z'\nPARTITION CPUS S:C:T    SOCKETS  CORES    THREADS\nparts*    4    2:2:1    2        2        1\n\nSee also 'sinfo --help' and 'man sinfo'\n\nsqueue\nFor user specified output formats (-o/--format) and sorting (-S/--sort),\nthe following identifiers are available:\n\n%m  Size of memory (in MB) requested by the job\n%H  Number of requested sockets per node\n%I  Number of requested cores per socket\n%J  Number of requested threads per core\n%z  Extended processor information: number of requested\n    sockets, cores, threads (S:C:T) per node\n\nBelow is an example squeue output after running 7 copies of:\n\n\n% srun -n 4 -B 2:2:1 --mem=1024 sleep 100 &\n\n\n\n% squeue -o '%.5i %.2t %.4M %.5D %7H %6I %7J %6z %R'\nJOBID ST TIME NODES SOCKETS CORES THREADS S:C:T NODELIST(REASON)\n   17 PD 0:00     1 2       2     1       2:2:1 (Resources)\n   18 PD 0:00     1 2       2     1       2:2:1 (Resources)\n   19 PD 0:00     1 2       2     1       2:2:1 (Resources)\n   13  R 1:27     1 2       2     1       2:2:1 hydra12\n   14  R 1:26     1 2       2     1       2:2:1 hydra13\n   15  R 1:26     1 2       2     1       2:2:1 hydra14\n   16  R 1:26     1 2       2     1       2:2:1 hydra15\n\nThe squeue command can also display the memory size of jobs, for example:\n\n% sbatch --mem=123 tmp\nSubmitted batch job 24\n\n$ squeue -o \"%.5i %.2t %.4M %.5D %m\"\nJOBID ST TIME NODES MIN_MEMORY\n  24   R 0:05     1 123\n\nSee also 'squeue --help' and 'man squeue'\n\nscontrol\nThe following job settings can be adjusted using scontrol:\n\n\nRequested Allocation:\n  ReqSockets=<count>  Set the job's count of required sockets\n  ReqCores=<count>    Set the job's count of required cores\n  ReqThreads=<count>  Set the job's count of required threads\n\nFor example:\n\n# scontrol update JobID=17 ReqThreads=2\n# scontrol update JobID=18 ReqCores=4\n# scontrol update JobID=19 ReqSockets=8\n\n% squeue -o '%.5i %.2t %.4M %.5D %9c %7H %6I %8J'\nJOBID ST TIME NODES MIN_PROCS SOCKETS CORES THREADS\n   17 PD 0:00     1 1         4       2     1\n   18 PD 0:00     1 1         8       4     2\n   19 PD 0:00     1 1         4       2     1\n   13  R 1:35     1 0         0       0     0\n   14  R 1:34     1 0         0       0     0\n   15  R 1:34     1 0         0       0     0\n   16  R 1:34     1 0         0       0     0\n\nThe 'scontrol show job' command can be used to display\nthe number of allocated CPUs per node as well as the socket, cores,\nand threads specified in the request and constraints.\n\n\n% srun -N 2 -B 2:1 sleep 100 &\n% scontrol show job 20\nJobId=20 UserId=(30352) GroupId=users(1051)\n   Name=sleep\n   Priority=4294901749 Partition=parts BatchFlag=0\n   AllocNode:Sid=hydra16:3892 TimeLimit=UNLIMITED\n   JobState=RUNNING StartTime=09/25-17:17:30 EndTime=NONE\n   NodeList=hydra[12-14] NodeListIndices=0,2,-1\n   AllocCPUs=1,2,1\n   NumCPUs=4 ReqNodes=2 ReqS:C:T=2:1:*\n   OverSubscribe=0 Contiguous=0 CPUs/task=0\n   MinCPUs=0 MinMemory=0 MinTmpDisk=0 Features=(null)\n   Dependency=0 Account=(null) Reason=None Network=(null)\n   ReqNodeList=(null) ReqNodeListIndices=-1\n   ExcNodeList=(null) ExcNodeListIndices=-1\n   SubmitTime=09/25-17:17:30 SuspendTime=None PreSusTime=0\n\nSee also 'scontrol --help' and 'man scontrol'\n\nConfiguration settings in slurm.conf\n\n\nSeveral slurm.conf settings are available to control the multi-core\nfeatures described above.\n\nIn addition to the description below, also see the \"Task Launch\" and\n\"Resource Selection\" sections if generating slurm.conf\nvia configurator.html.\n\nAs previously mentioned, in order for the affinity to be set, the\ntask/affinity plugin must be first enabled in slurm.conf:\n\n\nTaskPlugin=task/affinity          # enable task affinity\n\nThis setting is part of the task launch specific parameters:\n\n# o Define task launch specific parameters\n#\n#    \"TaskProlog\" : Define a program to be executed as the user before each\n#                   task begins execution.\n#    \"TaskEpilog\" : Define a program to be executed as the user after each\n#                   task terminates.\n#    \"TaskPlugin\" : Define a task launch plugin. This may be used to\n#                   provide resource management within a node (e.g. pinning\n#                   tasks to specific processors). Permissible values are:\n#      \"task/affinity\" : CPU affinity support\n#      \"task/cgroup\"   : bind tasks to resources using Linux cgroup\n#      \"task/none\"     : no task launch actions, the default\n#\n# Example:\n#\n# TaskProlog=/usr/local/slurm/etc/task_prolog # default is none\n# TaskEpilog=/usr/local/slurm/etc/task_epilog # default is none\n# TaskPlugin=task/affinity                    # default is task/none\n\nDeclare the node hardware configuration in slurm.conf:\n\n\nNodeName=dualcore[01-16] CoresPerSocket=2 ThreadsPerCore=1\n\nFor a more complete description of the various node configuration options\nsee the slurm.conf man page.\n\nLast modified 19 May 2023\n"
        },
        {
            "title": "\nSame cluster but with its core numbered cyclic instead of block\n\n",
            "content": "On a system with cyclically numbered cores, the correct mask\nargument to the srun command looks like: (this will\nachieve the same layout as the command above on a system with core block\nnumbering.)\n$ srun -n 32 -N 4 --cpu-bind=map_cpu:0,1,2,3,4,5,6,7 a.out\nBlock map_cpu on a system with cyclic core numbering\n\nIf users do not check their system's core numbering before specifying\nthe map_cpu list and thereby do not realize that the system has cyclic core\nnumbering instead of block numbering then they will not get the expected\nlayout. For example, if they decide to re-use their command from above:\n$ srun -n 32 -N 4 --cpu-bind=map_cpu:0,2,4,6,1,3,5,7 a.out\nthey get the following unintentional task ID layout:\n\n\n\n \nc0c1\np0 0  2 \np2 1  3 \n\n\n\n\n\n\n \nc0c1\np1 4  6 \np3 5  7 \n\n\n\nsince the processor IDs within a node in the cyclic numbering are:\n\n\n\n \nc0c1\np0 0  4 \np2 2  6 \n\n\n\n\n\n\n \nc0c1\np1 1  5 \np3 3  7 \n\n\n\nThe important conclusion is that using the --cpu-bind flag is not\ntrivial and that it assumes that users are experts.Extensions to sinfo/squeue/scontrol\n\nSeveral extensions have also been made to the other Slurm utilities to\nmake working with multi-core/multi-threaded systems easier.sinfoThe long version (-l) of the sinfo node listing (-N) has been\nextended to display the sockets, cores, and threads present for each\nnode.  For example:\n\n\n% sinfo -N\nNODELIST     NODES PARTITION STATE\nhydra[12-15]     4    parts* idle\n\n% sinfo -lN\nThu Sep 14 17:47:13 2006\nNODELIST     NODES PARTITION       STATE CPUS    S:C:T MEMORY TMP_DISK WEIGHT FEATURES REASON\nhydra[12-15]     4    parts*        idle   8+ 2+:4+:1+   2007    41447      1   (null) none\n\n% sinfo -lNe\nThu Sep 14 17:47:18 2006\nNODELIST     NODES PARTITION       STATE CPUS    S:C:T MEMORY TMP_DISK WEIGHT FEATURES REASON\n\nhydra[12-14]     3    parts*        idle    8    2:4:1   2007    41447      1   (null) none\nhydra15          1    parts*        idle   64    8:4:2   2007    41447      1   (null) none\n\nFor user specified output formats (-o/--format) and sorting (-S/--sort),\nthe following identifiers are available:\n\n%X  Number of sockets per node\n%Y  Number of cores per socket\n%Z  Number of threads per core\n%z  Extended processor information: number of\n    sockets, core, threads (S:C:T) per node\n\nFor example:\n\n% sinfo -o '%9P %4c %8z %8X %8Y %8Z'\nPARTITION CPUS S:C:T    SOCKETS  CORES    THREADS\nparts*    4    2:2:1    2        2        1\n\nSee also 'sinfo --help' and 'man sinfo'\n\nsqueue\nFor user specified output formats (-o/--format) and sorting (-S/--sort),\nthe following identifiers are available:\n\n%m  Size of memory (in MB) requested by the job\n%H  Number of requested sockets per node\n%I  Number of requested cores per socket\n%J  Number of requested threads per core\n%z  Extended processor information: number of requested\n    sockets, cores, threads (S:C:T) per node\n\nBelow is an example squeue output after running 7 copies of:\n\n\n% srun -n 4 -B 2:2:1 --mem=1024 sleep 100 &\n\n\n\n% squeue -o '%.5i %.2t %.4M %.5D %7H %6I %7J %6z %R'\nJOBID ST TIME NODES SOCKETS CORES THREADS S:C:T NODELIST(REASON)\n   17 PD 0:00     1 2       2     1       2:2:1 (Resources)\n   18 PD 0:00     1 2       2     1       2:2:1 (Resources)\n   19 PD 0:00     1 2       2     1       2:2:1 (Resources)\n   13  R 1:27     1 2       2     1       2:2:1 hydra12\n   14  R 1:26     1 2       2     1       2:2:1 hydra13\n   15  R 1:26     1 2       2     1       2:2:1 hydra14\n   16  R 1:26     1 2       2     1       2:2:1 hydra15\n\nThe squeue command can also display the memory size of jobs, for example:\n\n% sbatch --mem=123 tmp\nSubmitted batch job 24\n\n$ squeue -o \"%.5i %.2t %.4M %.5D %m\"\nJOBID ST TIME NODES MIN_MEMORY\n  24   R 0:05     1 123\n\nSee also 'squeue --help' and 'man squeue'\n\nscontrol\nThe following job settings can be adjusted using scontrol:\n\n\nRequested Allocation:\n  ReqSockets=<count>  Set the job's count of required sockets\n  ReqCores=<count>    Set the job's count of required cores\n  ReqThreads=<count>  Set the job's count of required threads\n\nFor example:\n\n# scontrol update JobID=17 ReqThreads=2\n# scontrol update JobID=18 ReqCores=4\n# scontrol update JobID=19 ReqSockets=8\n\n% squeue -o '%.5i %.2t %.4M %.5D %9c %7H %6I %8J'\nJOBID ST TIME NODES MIN_PROCS SOCKETS CORES THREADS\n   17 PD 0:00     1 1         4       2     1\n   18 PD 0:00     1 1         8       4     2\n   19 PD 0:00     1 1         4       2     1\n   13  R 1:35     1 0         0       0     0\n   14  R 1:34     1 0         0       0     0\n   15  R 1:34     1 0         0       0     0\n   16  R 1:34     1 0         0       0     0\n\nThe 'scontrol show job' command can be used to display\nthe number of allocated CPUs per node as well as the socket, cores,\nand threads specified in the request and constraints.\n\n\n% srun -N 2 -B 2:1 sleep 100 &\n% scontrol show job 20\nJobId=20 UserId=(30352) GroupId=users(1051)\n   Name=sleep\n   Priority=4294901749 Partition=parts BatchFlag=0\n   AllocNode:Sid=hydra16:3892 TimeLimit=UNLIMITED\n   JobState=RUNNING StartTime=09/25-17:17:30 EndTime=NONE\n   NodeList=hydra[12-14] NodeListIndices=0,2,-1\n   AllocCPUs=1,2,1\n   NumCPUs=4 ReqNodes=2 ReqS:C:T=2:1:*\n   OverSubscribe=0 Contiguous=0 CPUs/task=0\n   MinCPUs=0 MinMemory=0 MinTmpDisk=0 Features=(null)\n   Dependency=0 Account=(null) Reason=None Network=(null)\n   ReqNodeList=(null) ReqNodeListIndices=-1\n   ExcNodeList=(null) ExcNodeListIndices=-1\n   SubmitTime=09/25-17:17:30 SuspendTime=None PreSusTime=0\n\nSee also 'scontrol --help' and 'man scontrol'\n\nConfiguration settings in slurm.conf\n\n\nSeveral slurm.conf settings are available to control the multi-core\nfeatures described above.\n\nIn addition to the description below, also see the \"Task Launch\" and\n\"Resource Selection\" sections if generating slurm.conf\nvia configurator.html.\n\nAs previously mentioned, in order for the affinity to be set, the\ntask/affinity plugin must be first enabled in slurm.conf:\n\n\nTaskPlugin=task/affinity          # enable task affinity\n\nThis setting is part of the task launch specific parameters:\n\n# o Define task launch specific parameters\n#\n#    \"TaskProlog\" : Define a program to be executed as the user before each\n#                   task begins execution.\n#    \"TaskEpilog\" : Define a program to be executed as the user after each\n#                   task terminates.\n#    \"TaskPlugin\" : Define a task launch plugin. This may be used to\n#                   provide resource management within a node (e.g. pinning\n#                   tasks to specific processors). Permissible values are:\n#      \"task/affinity\" : CPU affinity support\n#      \"task/cgroup\"   : bind tasks to resources using Linux cgroup\n#      \"task/none\"     : no task launch actions, the default\n#\n# Example:\n#\n# TaskProlog=/usr/local/slurm/etc/task_prolog # default is none\n# TaskEpilog=/usr/local/slurm/etc/task_epilog # default is none\n# TaskPlugin=task/affinity                    # default is task/none\n\nDeclare the node hardware configuration in slurm.conf:\n\n\nNodeName=dualcore[01-16] CoresPerSocket=2 ThreadsPerCore=1\n\nFor a more complete description of the various node configuration options\nsee the slurm.conf man page.\n\nLast modified 19 May 2023\n"
        },
        {
            "title": "squeue",
            "content": "For user specified output formats (-o/--format) and sorting (-S/--sort),\nthe following identifiers are available:\n%m  Size of memory (in MB) requested by the job\n%H  Number of requested sockets per node\n%I  Number of requested cores per socket\n%J  Number of requested threads per core\n%z  Extended processor information: number of requested\n    sockets, cores, threads (S:C:T) per node\nBelow is an example squeue output after running 7 copies of:\n\n% srun -n 4 -B 2:2:1 --mem=1024 sleep 100 &\n\n\n% squeue -o '%.5i %.2t %.4M %.5D %7H %6I %7J %6z %R'\nJOBID ST TIME NODES SOCKETS CORES THREADS S:C:T NODELIST(REASON)\n   17 PD 0:00     1 2       2     1       2:2:1 (Resources)\n   18 PD 0:00     1 2       2     1       2:2:1 (Resources)\n   19 PD 0:00     1 2       2     1       2:2:1 (Resources)\n   13  R 1:27     1 2       2     1       2:2:1 hydra12\n   14  R 1:26     1 2       2     1       2:2:1 hydra13\n   15  R 1:26     1 2       2     1       2:2:1 hydra14\n   16  R 1:26     1 2       2     1       2:2:1 hydra15\nThe squeue command can also display the memory size of jobs, for example:\n% sbatch --mem=123 tmp\nSubmitted batch job 24\n\n$ squeue -o \"%.5i %.2t %.4M %.5D %m\"\nJOBID ST TIME NODES MIN_MEMORY\n  24   R 0:05     1 123\nSee also 'squeue --help' and 'man squeue'scontrolThe following job settings can be adjusted using scontrol:\n\n\nRequested Allocation:\n  ReqSockets=<count>  Set the job's count of required sockets\n  ReqCores=<count>    Set the job's count of required cores\n  ReqThreads=<count>  Set the job's count of required threads\n\nFor example:\n\n# scontrol update JobID=17 ReqThreads=2\n# scontrol update JobID=18 ReqCores=4\n# scontrol update JobID=19 ReqSockets=8\n\n% squeue -o '%.5i %.2t %.4M %.5D %9c %7H %6I %8J'\nJOBID ST TIME NODES MIN_PROCS SOCKETS CORES THREADS\n   17 PD 0:00     1 1         4       2     1\n   18 PD 0:00     1 1         8       4     2\n   19 PD 0:00     1 1         4       2     1\n   13  R 1:35     1 0         0       0     0\n   14  R 1:34     1 0         0       0     0\n   15  R 1:34     1 0         0       0     0\n   16  R 1:34     1 0         0       0     0\n\nThe 'scontrol show job' command can be used to display\nthe number of allocated CPUs per node as well as the socket, cores,\nand threads specified in the request and constraints.\n\n\n% srun -N 2 -B 2:1 sleep 100 &\n% scontrol show job 20\nJobId=20 UserId=(30352) GroupId=users(1051)\n   Name=sleep\n   Priority=4294901749 Partition=parts BatchFlag=0\n   AllocNode:Sid=hydra16:3892 TimeLimit=UNLIMITED\n   JobState=RUNNING StartTime=09/25-17:17:30 EndTime=NONE\n   NodeList=hydra[12-14] NodeListIndices=0,2,-1\n   AllocCPUs=1,2,1\n   NumCPUs=4 ReqNodes=2 ReqS:C:T=2:1:*\n   OverSubscribe=0 Contiguous=0 CPUs/task=0\n   MinCPUs=0 MinMemory=0 MinTmpDisk=0 Features=(null)\n   Dependency=0 Account=(null) Reason=None Network=(null)\n   ReqNodeList=(null) ReqNodeListIndices=-1\n   ExcNodeList=(null) ExcNodeListIndices=-1\n   SubmitTime=09/25-17:17:30 SuspendTime=None PreSusTime=0\n\nSee also 'scontrol --help' and 'man scontrol'\n\nConfiguration settings in slurm.conf\n\n\nSeveral slurm.conf settings are available to control the multi-core\nfeatures described above.\n\nIn addition to the description below, also see the \"Task Launch\" and\n\"Resource Selection\" sections if generating slurm.conf\nvia configurator.html.\n\nAs previously mentioned, in order for the affinity to be set, the\ntask/affinity plugin must be first enabled in slurm.conf:\n\n\nTaskPlugin=task/affinity          # enable task affinity\n\nThis setting is part of the task launch specific parameters:\n\n# o Define task launch specific parameters\n#\n#    \"TaskProlog\" : Define a program to be executed as the user before each\n#                   task begins execution.\n#    \"TaskEpilog\" : Define a program to be executed as the user after each\n#                   task terminates.\n#    \"TaskPlugin\" : Define a task launch plugin. This may be used to\n#                   provide resource management within a node (e.g. pinning\n#                   tasks to specific processors). Permissible values are:\n#      \"task/affinity\" : CPU affinity support\n#      \"task/cgroup\"   : bind tasks to resources using Linux cgroup\n#      \"task/none\"     : no task launch actions, the default\n#\n# Example:\n#\n# TaskProlog=/usr/local/slurm/etc/task_prolog # default is none\n# TaskEpilog=/usr/local/slurm/etc/task_epilog # default is none\n# TaskPlugin=task/affinity                    # default is task/none\n\nDeclare the node hardware configuration in slurm.conf:\n\n\nNodeName=dualcore[01-16] CoresPerSocket=2 ThreadsPerCore=1\n\nFor a more complete description of the various node configuration options\nsee the slurm.conf man page.\n\nLast modified 19 May 2023\n"
        }
    ]
}